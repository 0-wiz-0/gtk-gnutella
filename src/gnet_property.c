/*
 * Copyright (c) 2001-2002, Richard Eckart
 *
 * THIS FILE IS AUTOGENERATED! DO NOT EDIT!
 * This file is generated from gnet_props.ag using autogen.
 * Autogen is available at http://autogen.sourceforge.net/.
 *
 *----------------------------------------------------------------------
 * This file is part of gtk-gnutella.
 *
 *  gtk-gnutella is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  gtk-gnutella is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with gtk-gnutella; if not, write to the Free Software
 *  Foundation, Inc.:
 *      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *----------------------------------------------------------------------
 */

#include "prop.h"
#include "gnet_property.h"


/*
 * Includes specified by "uses"-statement in .ag file
 */
#include "sockets.h"
#include "gnet.h"
#include "bsched.h"



gboolean reading_hostfile     = FALSE;
gboolean reading_hostfile_def = FALSE;
gboolean reading_ultrafile     = FALSE;
gboolean reading_ultrafile_def = FALSE;
gboolean ancient_version     = FALSE;
gboolean ancient_version_def = FALSE;
gchar   *new_version_str     = NULL;
gchar   *new_version_str_def = NULL;
guint32  up_connections     = 3;
guint32  up_connections_def = 3;
guint32  normal_connections     = 2;
guint32  normal_connections_def = 2;
guint32  max_connections     = 4;
guint32  max_connections_def = 4;
guint32  node_leaf_count     = 0;
guint32  node_leaf_count_def = 0;
guint32  node_normal_count     = 0;
guint32  node_normal_count_def = 0;
guint32  node_ultra_count     = 0;
guint32  node_ultra_count_def = 0;
guint32  max_downloads     = 10;
guint32  max_downloads_def = 10;
guint32  max_host_downloads     = 1;
guint32  max_host_downloads_def = 1;
guint32  max_uploads     = 4;
guint32  max_uploads_def = 4;
guint32  max_uploads_ip     = 1;
guint32  max_uploads_ip_def = 1;
guint32  local_ip     = 0x00000000;
guint32  local_ip_def = 0x00000000;
guint32  current_ip_stamp     = 0;
guint32  current_ip_stamp_def = 0;
guint32  average_ip_uptime     = 0;
guint32  average_ip_uptime_def = 0;
guint32  start_stamp     = 0;
guint32  start_stamp_def = 0;
guint32  average_servent_uptime     = 0;
guint32  average_servent_uptime_def = 0;
guint32  listen_port     = 6346;
guint32  listen_port_def = 6346;
guint32  forced_local_ip     = 0x00000000;
guint32  forced_local_ip_def = 0x00000000;
guint32  connection_speed     = 0;
guint32  connection_speed_def = 0;
guint32  search_max_items     = 50;
guint32  search_max_items_def = 50;
guint32  ul_usage_min_percentage     = 70;
guint32  ul_usage_min_percentage_def = 70;
guint32  download_connecting_timeout     = 30;
guint32  download_connecting_timeout_def = 30;
guint32  download_push_sent_timeout     = 60;
guint32  download_push_sent_timeout_def = 60;
guint32  download_connected_timeout     = 60;
guint32  download_connected_timeout_def = 60;
guint32  download_retry_timeout_min     = 20;
guint32  download_retry_timeout_min_def = 20;
guint32  download_retry_timeout_max     = 120;
guint32  download_retry_timeout_max_def = 120;
guint32  download_max_retries     = 256;
guint32  download_max_retries_def = 256;
guint32  download_retry_timeout_delay     = 1200;
guint32  download_retry_timeout_delay_def = 1200;
guint32  download_retry_busy_delay     = 60;
guint32  download_retry_busy_delay_def = 60;
guint32  download_retry_refused_delay     = 1800;
guint32  download_retry_refused_delay_def = 1800;
guint32  download_retry_stopped_delay     = 15;
guint32  download_retry_stopped_delay_def = 15;
guint32  download_overlap_range     = 512;
guint32  download_overlap_range_def = 512;
guint32  upload_connecting_timeout     = 60;
guint32  upload_connecting_timeout_def = 60;
guint32  upload_connected_timeout     = 180;
guint32  upload_connected_timeout_def = 180;
guint32  search_reissue_timeout     = 1800;
guint32  search_reissue_timeout_def = 1800;
guint32  ban_ratio_fds     = 25;
guint32  ban_ratio_fds_def = 25;
guint32  ban_max_fds     = 100;
guint32  ban_max_fds_def = 100;
guint32  max_banned_fd     = 100;
guint32  max_banned_fd_def = 100;
guint32  incoming_connecting_timeout     = 30;
guint32  incoming_connecting_timeout_def = 30;
guint32  node_connecting_timeout     = 5;
guint32  node_connecting_timeout_def = 5;
guint32  node_connected_timeout     = 45;
guint32  node_connected_timeout_def = 45;
guint32  node_sendqueue_size     = 98304;
guint32  node_sendqueue_size_def = 98304;
guint32  node_tx_flowc_timeout     = 60;
guint32  node_tx_flowc_timeout_def = 60;
guint32  node_rx_flowc_ratio     = 50;
guint32  node_rx_flowc_ratio_def = 50;
guint32  max_ttl     = 10;
guint32  max_ttl_def = 10;
guint32  my_ttl     = 7;
guint32  my_ttl_def = 7;
guint32  hard_ttl_limit     = 15;
guint32  hard_ttl_limit_def = 15;
guint32  dbg     = 0;
guint32  dbg_def = 0;
gboolean stop_host_get     = FALSE;
gboolean stop_host_get_def = FALSE;
gboolean bws_in_enabled     = FALSE;
gboolean bws_in_enabled_def = FALSE;
gboolean bws_out_enabled     = FALSE;
gboolean bws_out_enabled_def = FALSE;
gboolean bws_gin_enabled     = FALSE;
gboolean bws_gin_enabled_def = FALSE;
gboolean bws_gout_enabled     = FALSE;
gboolean bws_gout_enabled_def = FALSE;
gboolean bw_ul_usage_enabled     = FALSE;
gboolean bw_ul_usage_enabled_def = FALSE;
gboolean bw_allow_stealing     = TRUE;
gboolean bw_allow_stealing_def = TRUE;
gboolean clear_downloads     = FALSE;
gboolean clear_downloads_def = FALSE;
gboolean search_remove_downloaded     = FALSE;
gboolean search_remove_downloaded_def = FALSE;
gboolean force_local_ip     = FALSE;
gboolean force_local_ip_def = FALSE;
gboolean use_netmasks     = FALSE;
gboolean use_netmasks_def = FALSE;
gboolean download_delete_aborted     = TRUE;
gboolean download_delete_aborted_def = TRUE;
gboolean proxy_connections     = FALSE;
gboolean proxy_connections_def = FALSE;
gboolean proxy_auth     = FALSE;
gboolean proxy_auth_def = FALSE;
gchar   *socks_user     = "username";
gchar   *socks_user_def = "username";
gchar   *socks_pass     = "password";
gchar   *socks_pass_def = "password";
guint32  proxy_ip     = 0x00000000;
guint32  proxy_ip_def = 0x00000000;
guint32  proxy_port     = 0x0000;
guint32  proxy_port_def = 0x0000;
guint32  proxy_protocol     = PROXY_NONE;
guint32  proxy_protocol_def = PROXY_NONE;
prop_def_choice_t proxy_protocol_choices[] = { 
    {"None", PROXY_NONE},
    {"HTTP", PROXY_HTTP},
    {"SOCKS v4", PROXY_SOCKSV4},
    {"SOCKS v5", PROXY_SOCKSV5},
    {NULL, 0}
};
guint32  max_hosts_cached     = 20480;
guint32  max_hosts_cached_def = 20480;
guint32  hosts_in_catcher     = 0;
guint32  hosts_in_catcher_def = 0;
guint32  hosts_in_ultra_catcher     = 0;
guint32  hosts_in_ultra_catcher_def = 0;
guint32  max_ultra_hosts_cached     = 20480;
guint32  max_ultra_hosts_cached_def = 20480;
guint32  max_high_ttl_msg     = 10;
guint32  max_high_ttl_msg_def = 10;
guint32  max_high_ttl_radius     = 2;
guint32  max_high_ttl_radius_def = 2;
guint32  bw_http_in     = 1024;
guint32  bw_http_in_def = 1024;
guint32  bw_http_out     = 1024;
guint32  bw_http_out_def = 1024;
guint32  bw_gnet_in     = 1024;
guint32  bw_gnet_in_def = 1024;
guint32  bw_gnet_out     = 1024;
guint32  bw_gnet_out_def = 1024;
guint32  search_queries_forward_size     = 256;
guint32  search_queries_forward_size_def = 256;
guint32  search_queries_kick_size     = 1024;
guint32  search_queries_kick_size_def = 1024;
guint32  search_answers_forward_size     = 65536;
guint32  search_answers_forward_size_def = 65536;
guint32  search_answers_kick_size     = 65536;
guint32  search_answers_kick_size_def = 65536;
guint32  other_messages_kick_size     = 40960;
guint32  other_messages_kick_size_def = 40960;
guint32  hops_random_factor     = 0;
guint32  hops_random_factor_def = 0;
gboolean send_pushes     = TRUE;
gboolean send_pushes_def = TRUE;
guint32  min_dup_msg     = 5;
guint32  min_dup_msg_def = 5;
guint32  min_dup_ratio     = 150;
guint32  min_dup_ratio_def = 150;
gchar   *scan_extensions     = "asf;avi;bin;bz2;cue;deb;divx;doc;flc;fli;gif;gz;ifo;iso;it;jpeg;jpg;mjpg;mod;mov;mpa;mpg;mpeg;mpega;mp4;mp3;mp2;mp1:mpv;nes;ogg;qt;png;ps;pdf;ram;rm;rar;rpm;rom;s3m;smc;smd;stm;tar;tgz;txt;vob;voc;vqf;wav;wma;wmv;xm;zip";
gchar   *scan_extensions_def = "asf;avi;bin;bz2;cue;deb;divx;doc;flc;fli;gif;gz;ifo;iso;it;jpeg;jpg;mjpg;mod;mov;mpa;mpg;mpeg;mpega;mp4;mp3;mp2;mp1:mpv;nes;ogg;qt;png;ps;pdf;ram;rm;rar;rpm;rom;s3m;smc;smd;stm;tar;tgz;txt;vob;voc;vqf;wav;wma;wmv;xm;zip";
gchar   *save_file_path     = "/tmp";
gchar   *save_file_path_def = "/tmp";
gchar   *move_file_path     = "/tmp";
gchar   *move_file_path_def = "/tmp";
gchar   *bad_file_path     = "/tmp";
gchar   *bad_file_path_def = "/tmp";
gchar   *shared_dirs_paths     = "";
gchar   *shared_dirs_paths_def = "";
gchar   *local_netmasks_string     = "";
gchar   *local_netmasks_string_def = "";
guint32  total_downloads     = 0;
guint32  total_downloads_def = 0;
guint32  total_uploads     = 0;
guint32  total_uploads_def = 0;
guint8   guid[16];
gboolean use_swarming     = TRUE;
gboolean use_swarming_def = TRUE;
gboolean use_aggressive_swarming     = TRUE;
gboolean use_aggressive_swarming_def = TRUE;
guint32  dl_minchunksize     = 512*1024;
guint32  dl_minchunksize_def = 512*1024;
guint32  dl_maxchunksize     = 10*1024*1024;
guint32  dl_maxchunksize_def = 10*1024*1024;
gboolean auto_download_identical     = TRUE;
gboolean auto_download_identical_def = TRUE;
gboolean strict_sha1_matching     = FALSE;
gboolean strict_sha1_matching_def = FALSE;
gboolean use_fuzzy_matching     = FALSE;
gboolean use_fuzzy_matching_def = FALSE;
guint32  fuzzy_threshold     = 70;
guint32  fuzzy_threshold_def = 70;
gboolean is_firewalled     = TRUE;
gboolean is_firewalled_def = TRUE;
gboolean is_inet_connected     = TRUE;
gboolean is_inet_connected_def = TRUE;
gboolean gnet_compact_query     = TRUE;
gboolean gnet_compact_query_def = TRUE;
gboolean download_optimistic_start     = FALSE;
gboolean download_optimistic_start_def = FALSE;
gboolean mark_ignored     = FALSE;
gboolean mark_ignored_def = FALSE;
gboolean library_rebuilding     = FALSE;
gboolean library_rebuilding_def = FALSE;
gboolean sha1_rebuilding     = FALSE;
gboolean sha1_rebuilding_def = FALSE;
gboolean sha1_verifying     = FALSE;
gboolean sha1_verifying_def = FALSE;
gboolean file_moving     = FALSE;
gboolean file_moving_def = FALSE;
gboolean prefer_compressed_gnet     = FALSE;
gboolean prefer_compressed_gnet_def = FALSE;
gboolean online_mode     = TRUE;
gboolean online_mode_def = TRUE;
guint32  lib_debug     = 0;
guint32  lib_debug_def = 0;
gboolean download_require_urn     = FALSE;
gboolean download_require_urn_def = FALSE;
gboolean download_require_server_name     = FALSE;
gboolean download_require_server_name_def = FALSE;
gboolean force_ultrapeer     = FALSE;
gboolean force_ultrapeer_def = FALSE;
gboolean force_leaf     = FALSE;
gboolean force_leaf_def = FALSE;
guint32  max_ultrapeers     = 3;
guint32  max_ultrapeers_def = 3;
guint32  max_leaves     = 100;
guint32  max_leaves_def = 100;
guint32  current_peermode     = 1;
guint32  current_peermode_def = 1;
prop_def_choice_t current_peermode_choices[] = { 
    {"ultra node (experimental)", 2},
    {"normal node", 1},
    {"leaf node", 0},
    {NULL, 0}
};
guint32  sys_nofile     = 1024;
guint32  sys_nofile_def = 1024;
guint32  sys_physmem     = 65536;
guint32  sys_physmem_def = 65536;
guint32  dl_queue_count     = 0;
guint32  dl_queue_count_def = 0;
guint32  dl_running_count     = 0;
guint32  dl_running_count_def = 0;
guint32  dl_qalive_count     = 0;
guint32  dl_qalive_count_def = 0;
guint32  dl_byte_count     = 0;
guint32  dl_byte_count_def = 0;
guint32  ul_byte_count     = 0;
guint32  ul_byte_count_def = 0;

static prop_set_t *gnet_property = NULL;

prop_set_t *gnet_prop_init(void) {
    gnet_property = g_new(prop_set_t, 1);
    gnet_property->name   = "gnet_property";
    gnet_property->desc   = "";
    gnet_property->size   = GNET_PROPERTY_NUM;
    gnet_property->offset = 0;
    gnet_property->mtime  = 0;
    gnet_property->props  = g_new(prop_def_t, GNET_PROPERTY_NUM);
    gnet_property->get_stub = gnet_prop_get_stub;


    /*
     * PROP_READING_HOSTFILE:
     *
     * General data:
     */
    gnet_property->props[0].name = "reading_hostfile";
    gnet_property->props[0].desc = "Indicates wether the hostcache file is being read";
    gnet_property->props[0].prop_changed_listeners = NULL;
    gnet_property->props[0].save = FALSE;
    gnet_property->props[0].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[0].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[0].data.boolean.def   = &reading_hostfile_def;
    gnet_property->props[0].data.boolean.value = &reading_hostfile;


    /*
     * PROP_READING_ULTRAFILE:
     *
     * General data:
     */
    gnet_property->props[1].name = "reading_ultrafile";
    gnet_property->props[1].desc = "Indicates wether the ultracache file is being read";
    gnet_property->props[1].prop_changed_listeners = NULL;
    gnet_property->props[1].save = FALSE;
    gnet_property->props[1].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[1].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[1].data.boolean.def   = &reading_ultrafile_def;
    gnet_property->props[1].data.boolean.value = &reading_ultrafile;


    /*
     * PROP_ANCIENT_VERSION:
     *
     * General data:
     */
    gnet_property->props[2].name = "ancient_version";
    gnet_property->props[2].desc = "Indicates that gtk-gnutella finds the version you run very very old";
    gnet_property->props[2].prop_changed_listeners = NULL;
    gnet_property->props[2].save = FALSE;
    gnet_property->props[2].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[2].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[2].data.boolean.def   = &ancient_version_def;
    gnet_property->props[2].data.boolean.value = &ancient_version;


    /*
     * PROP_NEW_VERSION_STR:
     *
     * General data:
     */
    gnet_property->props[3].name = "new_version_str";
    gnet_property->props[3].desc = "Gtk-gnutella found a newer version on the gNet and gives information about it here";
    gnet_property->props[3].prop_changed_listeners = NULL;
    gnet_property->props[3].save = FALSE;
    gnet_property->props[3].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[3].type               = PROP_TYPE_STRING;
    gnet_property->props[3].data.string.def    = &new_version_str_def;
    gnet_property->props[3].data.string.value  = &new_version_str;
    if (gnet_property->props[3].data.string.def) {
        *gnet_property->props[3].data.string.value =
            g_strdup(*gnet_property->props[3].data.string.def);
    }


    /*
     * PROP_UP_CONNECTIONS:
     *
     * General data:
     */
    gnet_property->props[4].name = "up_connections";
    gnet_property->props[4].desc = "Try to keep at least this number of connections to other servents of the same kind as we are (normal or ultra nodes). This should be smaller than the maximum amount of connections to allow incoming connections.";
    gnet_property->props[4].prop_changed_listeners = NULL;
    gnet_property->props[4].save = TRUE;
    gnet_property->props[4].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[4].type               = PROP_TYPE_GUINT32;
    gnet_property->props[4].data.guint32.def   = &up_connections_def;
    gnet_property->props[4].data.guint32.value = &up_connections;
    gnet_property->props[4].data.guint32.choices = NULL;
    gnet_property->props[4].data.guint32.max   = 100;
    gnet_property->props[4].data.guint32.min   = 0;


    /*
     * PROP_NORMAL_CONNECTIONS:
     *
     * General data:
     */
    gnet_property->props[5].name = "normal_connections";
    gnet_property->props[5].desc = "When in ultrapeer mode, try to keep at least this number of connections to normal servents.  This should be smaller than the maximum amount of connections to allow incoming connections.";
    gnet_property->props[5].prop_changed_listeners = NULL;
    gnet_property->props[5].save = TRUE;
    gnet_property->props[5].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[5].type               = PROP_TYPE_GUINT32;
    gnet_property->props[5].data.guint32.def   = &normal_connections_def;
    gnet_property->props[5].data.guint32.value = &normal_connections;
    gnet_property->props[5].data.guint32.choices = NULL;
    gnet_property->props[5].data.guint32.max   = 100;
    gnet_property->props[5].data.guint32.min   = 0;


    /*
     * PROP_MAX_CONNECTIONS:
     *
     * General data:
     */
    gnet_property->props[6].name = "max_connections";
    gnet_property->props[6].desc = "Don't allow more that this number of connections to other servents.  As a rule of thumb you should reserve 1kb/s bandwidth per connection. Never use up all your bandwidth, leave a little space for TCP/IP overhead. It's not advisable that you set this to a value larger then 10.";
    gnet_property->props[6].prop_changed_listeners = NULL;
    gnet_property->props[6].save = TRUE;
    gnet_property->props[6].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[6].type               = PROP_TYPE_GUINT32;
    gnet_property->props[6].data.guint32.def   = &max_connections_def;
    gnet_property->props[6].data.guint32.value = &max_connections;
    gnet_property->props[6].data.guint32.choices = NULL;
    gnet_property->props[6].data.guint32.max   = 100;
    gnet_property->props[6].data.guint32.min   = 0;


    /*
     * PROP_NODE_LEAF_COUNT:
     *
     * General data:
     */
    gnet_property->props[7].name = "node_leaf_count";
    gnet_property->props[7].desc = "Number of leaf nodes currently connected.";
    gnet_property->props[7].prop_changed_listeners = NULL;
    gnet_property->props[7].save = FALSE;
    gnet_property->props[7].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[7].type               = PROP_TYPE_GUINT32;
    gnet_property->props[7].data.guint32.def   = &node_leaf_count_def;
    gnet_property->props[7].data.guint32.value = &node_leaf_count;
    gnet_property->props[7].data.guint32.choices = NULL;
    gnet_property->props[7].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[7].data.guint32.min   = 0x00000000;


    /*
     * PROP_NODE_NORMAL_COUNT:
     *
     * General data:
     */
    gnet_property->props[8].name = "node_normal_count";
    gnet_property->props[8].desc = "Number of normal nodes currently connected.";
    gnet_property->props[8].prop_changed_listeners = NULL;
    gnet_property->props[8].save = FALSE;
    gnet_property->props[8].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[8].type               = PROP_TYPE_GUINT32;
    gnet_property->props[8].data.guint32.def   = &node_normal_count_def;
    gnet_property->props[8].data.guint32.value = &node_normal_count;
    gnet_property->props[8].data.guint32.choices = NULL;
    gnet_property->props[8].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[8].data.guint32.min   = 0x00000000;


    /*
     * PROP_NODE_ULTRA_COUNT:
     *
     * General data:
     */
    gnet_property->props[9].name = "node_ultra_count";
    gnet_property->props[9].desc = "Number of ultra nodes currently connected.";
    gnet_property->props[9].prop_changed_listeners = NULL;
    gnet_property->props[9].save = FALSE;
    gnet_property->props[9].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[9].type               = PROP_TYPE_GUINT32;
    gnet_property->props[9].data.guint32.def   = &node_ultra_count_def;
    gnet_property->props[9].data.guint32.value = &node_ultra_count;
    gnet_property->props[9].data.guint32.choices = NULL;
    gnet_property->props[9].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[9].data.guint32.min   = 0x00000000;


    /*
     * PROP_MAX_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[10].name = "max_simultaneous_downloads";
    gnet_property->props[10].desc = "Don't start more than this number of parallel downloads.  Others will remain in the queue waiting for a download slot.";
    gnet_property->props[10].prop_changed_listeners = NULL;
    gnet_property->props[10].save = TRUE;
    gnet_property->props[10].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[10].type               = PROP_TYPE_GUINT32;
    gnet_property->props[10].data.guint32.def   = &max_downloads_def;
    gnet_property->props[10].data.guint32.value = &max_downloads;
    gnet_property->props[10].data.guint32.choices = NULL;
    gnet_property->props[10].data.guint32.max   = 100;
    gnet_property->props[10].data.guint32.min   = 0;


    /*
     * PROP_MAX_HOST_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[11].name = "max_simultaneous_host_downloads";
    gnet_property->props[11].desc = "Don't make more connections than given here to a single host to download a file.  Be nice to others, and leave that at the default value (1).";
    gnet_property->props[11].prop_changed_listeners = NULL;
    gnet_property->props[11].save = TRUE;
    gnet_property->props[11].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[11].type               = PROP_TYPE_GUINT32;
    gnet_property->props[11].data.guint32.def   = &max_host_downloads_def;
    gnet_property->props[11].data.guint32.value = &max_host_downloads;
    gnet_property->props[11].data.guint32.choices = NULL;
    gnet_property->props[11].data.guint32.max   = 10;
    gnet_property->props[11].data.guint32.min   = 1;


    /*
     * PROP_MAX_UPLOADS:
     *
     * General data:
     */
    gnet_property->props[12].name = "max_simultaneous_uploads";
    gnet_property->props[12].desc = "Don't allow more than this number of uploads in total";
    gnet_property->props[12].prop_changed_listeners = NULL;
    gnet_property->props[12].save = TRUE;
    gnet_property->props[12].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[12].type               = PROP_TYPE_GUINT32;
    gnet_property->props[12].data.guint32.def   = &max_uploads_def;
    gnet_property->props[12].data.guint32.value = &max_uploads;
    gnet_property->props[12].data.guint32.choices = NULL;
    gnet_property->props[12].data.guint32.max   = 100;
    gnet_property->props[12].data.guint32.min   = 0;


    /*
     * PROP_MAX_UPLOADS_IP:
     *
     * General data:
     */
    gnet_property->props[13].name = "max_uploads_ip";
    gnet_property->props[13].desc = "Don't upload more than this number of files in parallel to a single host";
    gnet_property->props[13].prop_changed_listeners = NULL;
    gnet_property->props[13].save = TRUE;
    gnet_property->props[13].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[13].type               = PROP_TYPE_GUINT32;
    gnet_property->props[13].data.guint32.def   = &max_uploads_ip_def;
    gnet_property->props[13].data.guint32.value = &max_uploads_ip;
    gnet_property->props[13].data.guint32.choices = NULL;
    gnet_property->props[13].data.guint32.max   = 100;
    gnet_property->props[13].data.guint32.min   = 1;


    /*
     * PROP_LOCAL_IP:
     *
     * General data:
     */
    gnet_property->props[14].name = "local_ip";
    gnet_property->props[14].desc = "Local IP address last determined";
    gnet_property->props[14].prop_changed_listeners = NULL;
    gnet_property->props[14].save = TRUE;
    gnet_property->props[14].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[14].type               = PROP_TYPE_IP;
    gnet_property->props[14].data.guint32.def   = &local_ip_def;
    gnet_property->props[14].data.guint32.value = &local_ip;
    gnet_property->props[14].data.guint32.choices = NULL;
    gnet_property->props[14].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[14].data.guint32.min   = 0x00000000;


    /*
     * PROP_CURRENT_IP_STAMP:
     *
     * General data:
     */
    gnet_property->props[15].name = "current_ip_stamp";
    gnet_property->props[15].desc = "When the current IP address was determined";
    gnet_property->props[15].prop_changed_listeners = NULL;
    gnet_property->props[15].save = TRUE;
    gnet_property->props[15].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[15].type               = PROP_TYPE_GUINT32;
    gnet_property->props[15].data.guint32.def   = &current_ip_stamp_def;
    gnet_property->props[15].data.guint32.value = &current_ip_stamp;
    gnet_property->props[15].data.guint32.choices = NULL;
    gnet_property->props[15].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[15].data.guint32.min   = 0x00000000;


    /*
     * PROP_AVERAGE_IP_UPTIME:
     *
     * General data:
     */
    gnet_property->props[16].name = "average_ip_uptime";
    gnet_property->props[16].desc = "Average uptime with the same IP address";
    gnet_property->props[16].prop_changed_listeners = NULL;
    gnet_property->props[16].save = TRUE;
    gnet_property->props[16].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[16].type               = PROP_TYPE_GUINT32;
    gnet_property->props[16].data.guint32.def   = &average_ip_uptime_def;
    gnet_property->props[16].data.guint32.value = &average_ip_uptime;
    gnet_property->props[16].data.guint32.choices = NULL;
    gnet_property->props[16].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[16].data.guint32.min   = 0x00000000;


    /*
     * PROP_START_STAMP:
     *
     * General data:
     */
    gnet_property->props[17].name = "start_stamp";
    gnet_property->props[17].desc = "Timestamp at which servent was started";
    gnet_property->props[17].prop_changed_listeners = NULL;
    gnet_property->props[17].save = FALSE;
    gnet_property->props[17].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[17].type               = PROP_TYPE_GUINT32;
    gnet_property->props[17].data.guint32.def   = &start_stamp_def;
    gnet_property->props[17].data.guint32.value = &start_stamp;
    gnet_property->props[17].data.guint32.choices = NULL;
    gnet_property->props[17].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[17].data.guint32.min   = 0x00000000;


    /*
     * PROP_AVERAGE_SERVENT_UPTIME:
     *
     * General data:
     */
    gnet_property->props[18].name = "average_servent_uptime";
    gnet_property->props[18].desc = "Average servent uptime, in seconds";
    gnet_property->props[18].prop_changed_listeners = NULL;
    gnet_property->props[18].save = TRUE;
    gnet_property->props[18].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[18].type               = PROP_TYPE_GUINT32;
    gnet_property->props[18].data.guint32.def   = &average_servent_uptime_def;
    gnet_property->props[18].data.guint32.value = &average_servent_uptime;
    gnet_property->props[18].data.guint32.choices = NULL;
    gnet_property->props[18].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[18].data.guint32.min   = 0x00000000;


    /*
     * PROP_LISTEN_PORT:
     *
     * General data:
     */
    gnet_property->props[19].name = "listen_port";
    gnet_property->props[19].desc = "Local port gtk-gnutella is listening on";
    gnet_property->props[19].prop_changed_listeners = NULL;
    gnet_property->props[19].save = TRUE;
    gnet_property->props[19].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[19].type               = PROP_TYPE_GUINT32;
    gnet_property->props[19].data.guint32.def   = &listen_port_def;
    gnet_property->props[19].data.guint32.value = &listen_port;
    gnet_property->props[19].data.guint32.choices = NULL;
    gnet_property->props[19].data.guint32.max   = 0xFFFF;
    gnet_property->props[19].data.guint32.min   = 0x0000;


    /*
     * PROP_FORCED_LOCAL_IP:
     *
     * General data:
     */
    gnet_property->props[20].name = "forced_local_ip";
    gnet_property->props[20].desc = "Use this IP address as source address if 'force local ip' is activated";
    gnet_property->props[20].prop_changed_listeners = NULL;
    gnet_property->props[20].save = TRUE;
    gnet_property->props[20].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[20].type               = PROP_TYPE_IP;
    gnet_property->props[20].data.guint32.def   = &forced_local_ip_def;
    gnet_property->props[20].data.guint32.value = &forced_local_ip;
    gnet_property->props[20].data.guint32.choices = NULL;
    gnet_property->props[20].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[20].data.guint32.min   = 0x00000000;


    /*
     * PROP_CONNECTION_SPEED:
     *
     * General data:
     */
    gnet_property->props[21].name = "connection_speed";
    gnet_property->props[21].desc = "The connection bandwidth reported to other hosts";
    gnet_property->props[21].prop_changed_listeners = NULL;
    gnet_property->props[21].save = TRUE;
    gnet_property->props[21].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[21].type               = PROP_TYPE_GUINT32;
    gnet_property->props[21].data.guint32.def   = &connection_speed_def;
    gnet_property->props[21].data.guint32.value = &connection_speed;
    gnet_property->props[21].data.guint32.choices = NULL;
    gnet_property->props[21].data.guint32.max   = 2000;
    gnet_property->props[21].data.guint32.min   = 0;


    /*
     * PROP_QUERY_RESPONSE_MAX_ITEMS:
     *
     * General data:
     */
    gnet_property->props[22].name = "limit_search_results";
    gnet_property->props[22].desc = "Return at most this number of results to a query, using as many query hit packets as necessary.  To avoid network flooding, keep this to a reasonable value.";
    gnet_property->props[22].prop_changed_listeners = NULL;
    gnet_property->props[22].save = TRUE;
    gnet_property->props[22].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[22].type               = PROP_TYPE_GUINT32;
    gnet_property->props[22].data.guint32.def   = &search_max_items_def;
    gnet_property->props[22].data.guint32.value = &search_max_items;
    gnet_property->props[22].data.guint32.choices = NULL;
    gnet_property->props[22].data.guint32.max   = 500;
    gnet_property->props[22].data.guint32.min   = 1;


    /*
     * PROP_UL_USAGE_MIN_PERCENTAGE:
     *
     * General data:
     */
    gnet_property->props[23].name = "upload_bandwith_min_percentage";
    gnet_property->props[23].desc = "Unless this percentage or more of the upload bandwidth is used, allow additional upload slots";
    gnet_property->props[23].prop_changed_listeners = NULL;
    gnet_property->props[23].save = TRUE;
    gnet_property->props[23].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[23].type               = PROP_TYPE_GUINT32;
    gnet_property->props[23].data.guint32.def   = &ul_usage_min_percentage_def;
    gnet_property->props[23].data.guint32.value = &ul_usage_min_percentage;
    gnet_property->props[23].data.guint32.choices = NULL;
    gnet_property->props[23].data.guint32.max   = 100;
    gnet_property->props[23].data.guint32.min   = 0;


    /*
     * PROP_DOWNLOAD_CONNECTING_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[24].name = "download_connecting_timeout";
    gnet_property->props[24].desc = "Number of seconds before a download connect attempt times out";
    gnet_property->props[24].prop_changed_listeners = NULL;
    gnet_property->props[24].save = TRUE;
    gnet_property->props[24].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[24].type               = PROP_TYPE_GUINT32;
    gnet_property->props[24].data.guint32.def   = &download_connecting_timeout_def;
    gnet_property->props[24].data.guint32.value = &download_connecting_timeout;
    gnet_property->props[24].data.guint32.choices = NULL;
    gnet_property->props[24].data.guint32.max   = 100000;
    gnet_property->props[24].data.guint32.min   = 1;


    /*
     * PROP_DOWNLOAD_PUSH_SENT_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[25].name = "download_push_sent_timeout";
    gnet_property->props[25].desc = "Number of seconds before a push request times out";
    gnet_property->props[25].prop_changed_listeners = NULL;
    gnet_property->props[25].save = TRUE;
    gnet_property->props[25].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[25].type               = PROP_TYPE_GUINT32;
    gnet_property->props[25].data.guint32.def   = &download_push_sent_timeout_def;
    gnet_property->props[25].data.guint32.value = &download_push_sent_timeout;
    gnet_property->props[25].data.guint32.choices = NULL;
    gnet_property->props[25].data.guint32.max   = 100000;
    gnet_property->props[25].data.guint32.min   = 1;


    /*
     * PROP_DOWNLOAD_CONNECTED_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[26].name = "download_connected_timeout";
    gnet_property->props[26].desc = "Number of seconds before a download times out if no data is received";
    gnet_property->props[26].prop_changed_listeners = NULL;
    gnet_property->props[26].save = TRUE;
    gnet_property->props[26].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[26].type               = PROP_TYPE_GUINT32;
    gnet_property->props[26].data.guint32.def   = &download_connected_timeout_def;
    gnet_property->props[26].data.guint32.value = &download_connected_timeout;
    gnet_property->props[26].data.guint32.choices = NULL;
    gnet_property->props[26].data.guint32.max   = 100000;
    gnet_property->props[26].data.guint32.min   = 1;


    /*
     * PROP_DOWNLOAD_RETRY_TIMEOUT_MIN:
     *
     * General data:
     */
    gnet_property->props[27].name = "download_retry_timeout_min";
    gnet_property->props[27].desc = "Minimum number of seconds to wait on auto-retry timeouts";
    gnet_property->props[27].prop_changed_listeners = NULL;
    gnet_property->props[27].save = TRUE;
    gnet_property->props[27].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[27].type               = PROP_TYPE_GUINT32;
    gnet_property->props[27].data.guint32.def   = &download_retry_timeout_min_def;
    gnet_property->props[27].data.guint32.value = &download_retry_timeout_min;
    gnet_property->props[27].data.guint32.choices = NULL;
    gnet_property->props[27].data.guint32.max   = 100000;
    gnet_property->props[27].data.guint32.min   = 1;


    /*
     * PROP_DOWNLOAD_RETRY_TIMEOUT_MAX:
     *
     * General data:
     */
    gnet_property->props[28].name = "download_retry_timeout_max";
    gnet_property->props[28].desc = "Maximum number of seconds to wait on auto-retry timeouts";
    gnet_property->props[28].prop_changed_listeners = NULL;
    gnet_property->props[28].save = TRUE;
    gnet_property->props[28].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[28].type               = PROP_TYPE_GUINT32;
    gnet_property->props[28].data.guint32.def   = &download_retry_timeout_max_def;
    gnet_property->props[28].data.guint32.value = &download_retry_timeout_max;
    gnet_property->props[28].data.guint32.choices = NULL;
    gnet_property->props[28].data.guint32.max   = 100000;
    gnet_property->props[28].data.guint32.min   = 1;


    /*
     * PROP_DOWNLOAD_MAX_RETRIES:
     *
     * General data:
     */
    gnet_property->props[29].name = "download_max_retries";
    gnet_property->props[29].desc = "Maximum number of attempts to download a file not counting HTTP busy indications";
    gnet_property->props[29].prop_changed_listeners = NULL;
    gnet_property->props[29].save = TRUE;
    gnet_property->props[29].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[29].type               = PROP_TYPE_GUINT32;
    gnet_property->props[29].data.guint32.def   = &download_max_retries_def;
    gnet_property->props[29].data.guint32.value = &download_max_retries;
    gnet_property->props[29].data.guint32.choices = NULL;
    gnet_property->props[29].data.guint32.max   = 100000;
    gnet_property->props[29].data.guint32.min   = 1;


    /*
     * PROP_DOWNLOAD_RETRY_TIMEOUT_DELAY:
     *
     * General data:
     */
    gnet_property->props[30].name = "download_retry_timeout_delay";
    gnet_property->props[30].desc = "Delay in seconds before retrying after a connection timed out";
    gnet_property->props[30].prop_changed_listeners = NULL;
    gnet_property->props[30].save = TRUE;
    gnet_property->props[30].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[30].type               = PROP_TYPE_GUINT32;
    gnet_property->props[30].data.guint32.def   = &download_retry_timeout_delay_def;
    gnet_property->props[30].data.guint32.value = &download_retry_timeout_delay;
    gnet_property->props[30].data.guint32.choices = NULL;
    gnet_property->props[30].data.guint32.max   = 100000;
    gnet_property->props[30].data.guint32.min   = 15;


    /*
     * PROP_DOWNLOAD_RETRY_BUSY_DELAY:
     *
     * General data:
     */
    gnet_property->props[31].name = "download_retry_busy_delay";
    gnet_property->props[31].desc = "Delay in seconds before retrying after getting a 'busy' response from a host";
    gnet_property->props[31].prop_changed_listeners = NULL;
    gnet_property->props[31].save = TRUE;
    gnet_property->props[31].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[31].type               = PROP_TYPE_GUINT32;
    gnet_property->props[31].data.guint32.def   = &download_retry_busy_delay_def;
    gnet_property->props[31].data.guint32.value = &download_retry_busy_delay;
    gnet_property->props[31].data.guint32.choices = NULL;
    gnet_property->props[31].data.guint32.max   = 100000;
    gnet_property->props[31].data.guint32.min   = 15;


    /*
     * PROP_DOWNLOAD_RETRY_REFUSED_DELAY:
     *
     * General data:
     */
    gnet_property->props[32].name = "download_retry_refused_delay";
    gnet_property->props[32].desc = "Delay in seconds before retrying after getting a 'connection refused' response from a host";
    gnet_property->props[32].prop_changed_listeners = NULL;
    gnet_property->props[32].save = TRUE;
    gnet_property->props[32].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[32].type               = PROP_TYPE_GUINT32;
    gnet_property->props[32].data.guint32.def   = &download_retry_refused_delay_def;
    gnet_property->props[32].data.guint32.value = &download_retry_refused_delay;
    gnet_property->props[32].data.guint32.choices = NULL;
    gnet_property->props[32].data.guint32.max   = 100000;
    gnet_property->props[32].data.guint32.min   = 15;


    /*
     * PROP_DOWNLOAD_RETRY_STOPPED_DELAY:
     *
     * General data:
     */
    gnet_property->props[33].name = "download_retry_stopped";
    gnet_property->props[33].desc = "Delay in seconds before retrying after a retry stopped (timed out, connection reset by peer, etc...)";
    gnet_property->props[33].prop_changed_listeners = NULL;
    gnet_property->props[33].save = TRUE;
    gnet_property->props[33].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[33].type               = PROP_TYPE_GUINT32;
    gnet_property->props[33].data.guint32.def   = &download_retry_stopped_delay_def;
    gnet_property->props[33].data.guint32.value = &download_retry_stopped_delay;
    gnet_property->props[33].data.guint32.choices = NULL;
    gnet_property->props[33].data.guint32.max   = 100000;
    gnet_property->props[33].data.guint32.min   = 15;


    /*
     * PROP_DOWNLOAD_OVERLAP_RANGE:
     *
     * General data:
     */
    gnet_property->props[34].name = "download_overlap_range";
    gnet_property->props[34].desc = "Ammount of bytes to overlap when resuming a download. It should be at least 64 bytes for safe resuming, otherwise gtk-gnutella will not accept to resume a file for which we had no SHA1 known, after a server gives one back.";
    gnet_property->props[34].prop_changed_listeners = NULL;
    gnet_property->props[34].save = TRUE;
    gnet_property->props[34].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[34].type               = PROP_TYPE_GUINT32;
    gnet_property->props[34].data.guint32.def   = &download_overlap_range_def;
    gnet_property->props[34].data.guint32.value = &download_overlap_range;
    gnet_property->props[34].data.guint32.choices = NULL;
    gnet_property->props[34].data.guint32.max   = SOCK_BUFSZ;
    gnet_property->props[34].data.guint32.min   = 0;


    /*
     * PROP_UPLOAD_CONNECTING_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[35].name = "upload_connecting_timeout";
    gnet_property->props[35].desc = "Number of seconds before an upload times out if no connection can be established during a push.  It is also the maximum amount of time we wait to get the whole HTTP request.";
    gnet_property->props[35].prop_changed_listeners = NULL;
    gnet_property->props[35].save = TRUE;
    gnet_property->props[35].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[35].type               = PROP_TYPE_GUINT32;
    gnet_property->props[35].data.guint32.def   = &upload_connecting_timeout_def;
    gnet_property->props[35].data.guint32.value = &upload_connecting_timeout;
    gnet_property->props[35].data.guint32.choices = NULL;
    gnet_property->props[35].data.guint32.max   = 100000;
    gnet_property->props[35].data.guint32.min   = 1;


    /*
     * PROP_UPLOAD_CONNECTED_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[36].name = "upload_connected_timeout";
    gnet_property->props[36].desc = "Number of seconds after which an upload times out if no data is transmitted";
    gnet_property->props[36].prop_changed_listeners = NULL;
    gnet_property->props[36].save = TRUE;
    gnet_property->props[36].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[36].type               = PROP_TYPE_GUINT32;
    gnet_property->props[36].data.guint32.def   = &upload_connected_timeout_def;
    gnet_property->props[36].data.guint32.value = &upload_connected_timeout;
    gnet_property->props[36].data.guint32.choices = NULL;
    gnet_property->props[36].data.guint32.max   = 100000;
    gnet_property->props[36].data.guint32.min   = 1;


    /*
     * PROP_SEARCH_REISSUE_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[37].name = "search_reissue_timeout";
    gnet_property->props[37].desc = "Ammount of seconds to wait before a search is issued again to see if new results are available.  Be very careful with that parameter, and do not set it too low or you will damage the Gnutella network.  A delay of half an hour is fine.";
    gnet_property->props[37].prop_changed_listeners = NULL;
    gnet_property->props[37].save = TRUE;
    gnet_property->props[37].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[37].type               = PROP_TYPE_GUINT32;
    gnet_property->props[37].data.guint32.def   = &search_reissue_timeout_def;
    gnet_property->props[37].data.guint32.value = &search_reissue_timeout;
    gnet_property->props[37].data.guint32.choices = NULL;
    gnet_property->props[37].data.guint32.max   = 9999;
    gnet_property->props[37].data.guint32.min   = 600;


    /*
     * PROP_BAN_RATIO_FDS:
     *
     * General data:
     */
    gnet_property->props[38].name = "ban_ratio_fds";
    gnet_property->props[38].desc = "Maximum ratio of file descriptors reserved for banning. For instance, if your OS gives your 350 file descriptors, a ratio of 10 will reserve at most 35 file descriptors.  You should ensure you have around 100 file descriptors for efficient banning.";
    gnet_property->props[38].prop_changed_listeners = NULL;
    gnet_property->props[38].save = TRUE;
    gnet_property->props[38].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[38].type               = PROP_TYPE_GUINT32;
    gnet_property->props[38].data.guint32.def   = &ban_ratio_fds_def;
    gnet_property->props[38].data.guint32.value = &ban_ratio_fds;
    gnet_property->props[38].data.guint32.choices = NULL;
    gnet_property->props[38].data.guint32.max   = 100;
    gnet_property->props[38].data.guint32.min   = 0;


    /*
     * PROP_BAN_MAX_FDS:
     *
     * General data:
     */
    gnet_property->props[39].name = "ban_max_fds";
    gnet_property->props[39].desc = "Maximum number of file descriptors reserved for banning";
    gnet_property->props[39].prop_changed_listeners = NULL;
    gnet_property->props[39].save = TRUE;
    gnet_property->props[39].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[39].type               = PROP_TYPE_GUINT32;
    gnet_property->props[39].data.guint32.def   = &ban_max_fds_def;
    gnet_property->props[39].data.guint32.value = &ban_max_fds;
    gnet_property->props[39].data.guint32.choices = NULL;
    gnet_property->props[39].data.guint32.max   = 10000;
    gnet_property->props[39].data.guint32.min   = 0;


    /*
     * PROP_MAX_BANNED_FD:
     *
     * General data:
     */
    gnet_property->props[40].name = "max_banned_fd";
    gnet_property->props[40].desc = "Number of file descriptors we'll actually be using for banning";
    gnet_property->props[40].prop_changed_listeners = NULL;
    gnet_property->props[40].save = FALSE;
    gnet_property->props[40].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[40].type               = PROP_TYPE_GUINT32;
    gnet_property->props[40].data.guint32.def   = &max_banned_fd_def;
    gnet_property->props[40].data.guint32.value = &max_banned_fd;
    gnet_property->props[40].data.guint32.choices = NULL;
    gnet_property->props[40].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[40].data.guint32.min   = 0x00000000;


    /*
     * PROP_INCOMING_CONNECTING_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[41].name = "incoming_connecting_timeout";
    gnet_property->props[41].desc = "Number of seconds an incoming connection has to start sending out its request";
    gnet_property->props[41].prop_changed_listeners = NULL;
    gnet_property->props[41].save = TRUE;
    gnet_property->props[41].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[41].type               = PROP_TYPE_GUINT32;
    gnet_property->props[41].data.guint32.def   = &incoming_connecting_timeout_def;
    gnet_property->props[41].data.guint32.value = &incoming_connecting_timeout;
    gnet_property->props[41].data.guint32.choices = NULL;
    gnet_property->props[41].data.guint32.max   = 300;
    gnet_property->props[41].data.guint32.min   = 5;


    /*
     * PROP_NODE_CONNECTING_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[42].name = "node_connecting_timeout";
    gnet_property->props[42].desc = "Number of seconds before a Gnet connect attempt times out if no connection can be established";
    gnet_property->props[42].prop_changed_listeners = NULL;
    gnet_property->props[42].save = TRUE;
    gnet_property->props[42].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[42].type               = PROP_TYPE_GUINT32;
    gnet_property->props[42].data.guint32.def   = &node_connecting_timeout_def;
    gnet_property->props[42].data.guint32.value = &node_connecting_timeout;
    gnet_property->props[42].data.guint32.choices = NULL;
    gnet_property->props[42].data.guint32.max   = 100000;
    gnet_property->props[42].data.guint32.min   = 1;


    /*
     * PROP_NODE_CONNECTED_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[43].name = "node_connected_timeout";
    gnet_property->props[43].desc = "Number of seconds before a Gnet connection times out if no data is transmitted";
    gnet_property->props[43].prop_changed_listeners = NULL;
    gnet_property->props[43].save = TRUE;
    gnet_property->props[43].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[43].type               = PROP_TYPE_GUINT32;
    gnet_property->props[43].data.guint32.def   = &node_connected_timeout_def;
    gnet_property->props[43].data.guint32.value = &node_connected_timeout;
    gnet_property->props[43].data.guint32.choices = NULL;
    gnet_property->props[43].data.guint32.max   = 100000;
    gnet_property->props[43].data.guint32.min   = 1;


    /*
     * PROP_NODE_SENDQUEUE_SIZE:
     *
     * General data:
     */
    gnet_property->props[44].name = "node_sendqueue_size";
    gnet_property->props[44].desc = "Maximum size of the sendqueue for the nodes (in bytes). Must be at lest 150% of the maximum message size";
    gnet_property->props[44].prop_changed_listeners = NULL;
    gnet_property->props[44].save = TRUE;
    gnet_property->props[44].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[44].type               = PROP_TYPE_GUINT32;
    gnet_property->props[44].data.guint32.def   = &node_sendqueue_size_def;
    gnet_property->props[44].data.guint32.value = &node_sendqueue_size;
    gnet_property->props[44].data.guint32.choices = NULL;
    gnet_property->props[44].data.guint32.max   = 256000;
    gnet_property->props[44].data.guint32.min   = 98305;


    /*
     * PROP_NODE_TX_FLOWC_TIMEOUT:
     *
     * General data:
     */
    gnet_property->props[45].name = "node_tx_flowc_timeout";
    gnet_property->props[45].desc = "Maximum number of seconds a node can remain in transmit flow control before being kicked out.";
    gnet_property->props[45].prop_changed_listeners = NULL;
    gnet_property->props[45].save = TRUE;
    gnet_property->props[45].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[45].type               = PROP_TYPE_GUINT32;
    gnet_property->props[45].data.guint32.def   = &node_tx_flowc_timeout_def;
    gnet_property->props[45].data.guint32.value = &node_tx_flowc_timeout;
    gnet_property->props[45].data.guint32.choices = NULL;
    gnet_property->props[45].data.guint32.max   = 100000;
    gnet_property->props[45].data.guint32.min   = 5;


    /*
     * PROP_NODE_RX_FLOWC_RATIO:
     *
     * General data:
     */
    gnet_property->props[46].name = "node_rx_flowc_ratio";
    gnet_property->props[46].desc = "Maximum percentage of time over 5 minutes that our node can remain in flow control remotely before dropping the connection.  This only works with nodes that will send us an hops-flow message when they are flow-controlling us.";
    gnet_property->props[46].prop_changed_listeners = NULL;
    gnet_property->props[46].save = TRUE;
    gnet_property->props[46].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[46].type               = PROP_TYPE_GUINT32;
    gnet_property->props[46].data.guint32.def   = &node_rx_flowc_ratio_def;
    gnet_property->props[46].data.guint32.value = &node_rx_flowc_ratio;
    gnet_property->props[46].data.guint32.choices = NULL;
    gnet_property->props[46].data.guint32.max   = 100;
    gnet_property->props[46].data.guint32.min   = 10;


    /*
     * PROP_MAX_TTL:
     *
     * General data:
     */
    gnet_property->props[47].name = "max_ttl";
    gnet_property->props[47].desc = "Maximum TTL we allow in messages we broadcast.  If a message comes in with a TTL greater than that, it will be trimmed down to that value.  On Gnutella, the standard is TTL=7, so you cannot set a value lower than that.";
    gnet_property->props[47].prop_changed_listeners = NULL;
    gnet_property->props[47].save = TRUE;
    gnet_property->props[47].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[47].type               = PROP_TYPE_GUINT32;
    gnet_property->props[47].data.guint32.def   = &max_ttl_def;
    gnet_property->props[47].data.guint32.value = &max_ttl;
    gnet_property->props[47].data.guint32.choices = NULL;
    gnet_property->props[47].data.guint32.max   = 20;
    gnet_property->props[47].data.guint32.min   = 7;


    /*
     * PROP_MY_TTL:
     *
     * General data:
     */
    gnet_property->props[48].name = "my_ttl";
    gnet_property->props[48].desc = "The TTL we use in messages we generate.  The default on Gnutella is TTL=7.  If you set it to too large a value, you run the risk of being trimmed down by fellow gtk-gnutella nodes, or kicked out by some other servent.";
    gnet_property->props[48].prop_changed_listeners = NULL;
    gnet_property->props[48].save = TRUE;
    gnet_property->props[48].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[48].type               = PROP_TYPE_GUINT32;
    gnet_property->props[48].data.guint32.def   = &my_ttl_def;
    gnet_property->props[48].data.guint32.value = &my_ttl;
    gnet_property->props[48].data.guint32.choices = NULL;
    gnet_property->props[48].data.guint32.max   = 15;
    gnet_property->props[48].data.guint32.min   = 1;


    /*
     * PROP_HARD_TTL_LIMIT:
     *
     * General data:
     */
    gnet_property->props[49].name = "hard_ttl_limit";
    gnet_property->props[49].desc = "Maximum hard TTL limit (hops + TTL) on messages we relay.  This should be greater than the standard TTL=7, because it also applied to routed-back messages (query hits) that could be re-routed in case a connection is lost.  Standard broadcasted messages have their TTL limited by the maximum TTL you configure, and that limit should be much lower than the value of this parameter.";
    gnet_property->props[49].prop_changed_listeners = NULL;
    gnet_property->props[49].save = TRUE;
    gnet_property->props[49].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[49].type               = PROP_TYPE_GUINT32;
    gnet_property->props[49].data.guint32.def   = &hard_ttl_limit_def;
    gnet_property->props[49].data.guint32.value = &hard_ttl_limit;
    gnet_property->props[49].data.guint32.choices = NULL;
    gnet_property->props[49].data.guint32.max   = 25;
    gnet_property->props[49].data.guint32.min   = 9;


    /*
     * PROP_DBG:
     *
     * General data:
     */
    gnet_property->props[50].name = "dbg";
    gnet_property->props[50].desc = "For development use: debug level";
    gnet_property->props[50].prop_changed_listeners = NULL;
    gnet_property->props[50].save = TRUE;
    gnet_property->props[50].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[50].type               = PROP_TYPE_GUINT32;
    gnet_property->props[50].data.guint32.def   = &dbg_def;
    gnet_property->props[50].data.guint32.value = &dbg;
    gnet_property->props[50].data.guint32.choices = NULL;
    gnet_property->props[50].data.guint32.max   = 20;
    gnet_property->props[50].data.guint32.min   = 0;


    /*
     * PROP_STOP_HOST_GET:
     *
     * General data:
     */
    gnet_property->props[51].name = "stop_host_get";
    gnet_property->props[51].desc = "For development use: don't add new hosts to the hostcatcher";
    gnet_property->props[51].prop_changed_listeners = NULL;
    gnet_property->props[51].save = TRUE;
    gnet_property->props[51].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[51].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[51].data.boolean.def   = &stop_host_get_def;
    gnet_property->props[51].data.boolean.value = &stop_host_get;


    /*
     * PROP_BW_HTTP_IN_ENABLED:
     *
     * General data:
     */
    gnet_property->props[52].name = "bandwidth_input_limit";
    gnet_property->props[52].desc = "Enable bandwidth limitation for incoming HTTP traffic";
    gnet_property->props[52].prop_changed_listeners = NULL;
    gnet_property->props[52].save = TRUE;
    gnet_property->props[52].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[52].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[52].data.boolean.def   = &bws_in_enabled_def;
    gnet_property->props[52].data.boolean.value = &bws_in_enabled;


    /*
     * PROP_BW_HTTP_OUT_ENABLED:
     *
     * General data:
     */
    gnet_property->props[53].name = "bandwidth_output_limit";
    gnet_property->props[53].desc = "Enable bandwidth limitation for outgoing HTTP traffic";
    gnet_property->props[53].prop_changed_listeners = NULL;
    gnet_property->props[53].save = TRUE;
    gnet_property->props[53].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[53].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[53].data.boolean.def   = &bws_out_enabled_def;
    gnet_property->props[53].data.boolean.value = &bws_out_enabled;


    /*
     * PROP_BW_GNET_IN_ENABLED:
     *
     * General data:
     */
    gnet_property->props[54].name = "bandwidth_ginput_limit";
    gnet_property->props[54].desc = "Enable bandwidth limitation for incoming Gnet traffic";
    gnet_property->props[54].prop_changed_listeners = NULL;
    gnet_property->props[54].save = TRUE;
    gnet_property->props[54].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[54].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[54].data.boolean.def   = &bws_gin_enabled_def;
    gnet_property->props[54].data.boolean.value = &bws_gin_enabled;


    /*
     * PROP_BW_GNET_OUT_ENABLED:
     *
     * General data:
     */
    gnet_property->props[55].name = "bandwidth_goutput_limit";
    gnet_property->props[55].desc = "Enable bandwidth limitation for outgoing Gnet traffic";
    gnet_property->props[55].prop_changed_listeners = NULL;
    gnet_property->props[55].save = TRUE;
    gnet_property->props[55].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[55].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[55].data.boolean.def   = &bws_gout_enabled_def;
    gnet_property->props[55].data.boolean.value = &bws_gout_enabled;


    /*
     * PROP_BW_UL_USAGE_ENABLED:
     *
     * General data:
     */
    gnet_property->props[56].name = "upload_bandwith_usage_enabled";
    gnet_property->props[56].desc = "Enable dynamic upload slots allocation";
    gnet_property->props[56].prop_changed_listeners = NULL;
    gnet_property->props[56].save = TRUE;
    gnet_property->props[56].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[56].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[56].data.boolean.def   = &bw_ul_usage_enabled_def;
    gnet_property->props[56].data.boolean.value = &bw_ul_usage_enabled;


    /*
     * PROP_BW_ALLOW_STEALING:
     *
     * General data:
     */
    gnet_property->props[57].name = "bw_allow_stealing";
    gnet_property->props[57].desc = "Allow HTTP and Gnutella to grab whatever bandwidth the other is not using.  If FALSE, unused bandwidth is lost.";
    gnet_property->props[57].prop_changed_listeners = NULL;
    gnet_property->props[57].save = TRUE;
    gnet_property->props[57].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[57].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[57].data.boolean.def   = &bw_allow_stealing_def;
    gnet_property->props[57].data.boolean.value = &bw_allow_stealing;


    /*
     * PROP_AUTOCLEAR_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[58].name = "auto_clear_completed_downloads";
    gnet_property->props[58].desc = "Auto clear completed downloads";
    gnet_property->props[58].prop_changed_listeners = NULL;
    gnet_property->props[58].save = TRUE;
    gnet_property->props[58].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[58].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[58].data.boolean.def   = &clear_downloads_def;
    gnet_property->props[58].data.boolean.value = &clear_downloads;


    /*
     * PROP_SEARCH_REMOVE_DOWNLOADED:
     *
     * General data:
     */
    gnet_property->props[59].name = "search_remove_downloaded";
    gnet_property->props[59].desc = "Remove downloaded files from the search result";
    gnet_property->props[59].prop_changed_listeners = NULL;
    gnet_property->props[59].save = TRUE;
    gnet_property->props[59].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[59].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[59].data.boolean.def   = &search_remove_downloaded_def;
    gnet_property->props[59].data.boolean.value = &search_remove_downloaded;


    /*
     * PROP_FORCE_LOCAL_IP:
     *
     * General data:
     */
    gnet_property->props[60].name = "force_local_ip";
    gnet_property->props[60].desc = "Enable to use [forced_local_ip] as local ip";
    gnet_property->props[60].prop_changed_listeners = NULL;
    gnet_property->props[60].save = TRUE;
    gnet_property->props[60].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[60].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[60].data.boolean.def   = &force_local_ip_def;
    gnet_property->props[60].data.boolean.value = &force_local_ip;


    /*
     * PROP_USE_NETMASKS:
     *
     * General data:
     */
    gnet_property->props[61].name = "use_netmasks";
    gnet_property->props[61].desc = "Try to connect to local networks first";
    gnet_property->props[61].prop_changed_listeners = NULL;
    gnet_property->props[61].save = TRUE;
    gnet_property->props[61].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[61].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[61].data.boolean.def   = &use_netmasks_def;
    gnet_property->props[61].data.boolean.value = &use_netmasks;


    /*
     * PROP_DOWNLOAD_DELETE_ABORTED:
     *
     * General data:
     */
    gnet_property->props[62].name = "download_delete_aborted";
    gnet_property->props[62].desc = "Remove files of aborted downloads from disk";
    gnet_property->props[62].prop_changed_listeners = NULL;
    gnet_property->props[62].save = TRUE;
    gnet_property->props[62].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[62].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[62].data.boolean.def   = &download_delete_aborted_def;
    gnet_property->props[62].data.boolean.value = &download_delete_aborted;


    /*
     * PROP_PROXY_CONNECTIONS:
     *
     * General data:
     */
    gnet_property->props[63].name = "proxy_connections";
    gnet_property->props[63].desc = "DEPRECATED and automatically set to TRUE. Use a proxy to connect to the internet";
    gnet_property->props[63].prop_changed_listeners = NULL;
    gnet_property->props[63].save = TRUE;
    gnet_property->props[63].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[63].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[63].data.boolean.def   = &proxy_connections_def;
    gnet_property->props[63].data.boolean.value = &proxy_connections;


    /*
     * PROP_PROXY_AUTH:
     *
     * General data:
     */
    gnet_property->props[64].name = "proxy_auth";
    gnet_property->props[64].desc = "Use username and password to authenticate to proxy";
    gnet_property->props[64].prop_changed_listeners = NULL;
    gnet_property->props[64].save = TRUE;
    gnet_property->props[64].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[64].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[64].data.boolean.def   = &proxy_auth_def;
    gnet_property->props[64].data.boolean.value = &proxy_auth;


    /*
     * PROP_SOCKS_USER:
     *
     * General data:
     */
    gnet_property->props[65].name = "socks_user";
    gnet_property->props[65].desc = "Username for proxy";
    gnet_property->props[65].prop_changed_listeners = NULL;
    gnet_property->props[65].save = TRUE;
    gnet_property->props[65].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[65].type               = PROP_TYPE_STRING;
    gnet_property->props[65].data.string.def    = &socks_user_def;
    gnet_property->props[65].data.string.value  = &socks_user;
    if (gnet_property->props[65].data.string.def) {
        *gnet_property->props[65].data.string.value =
            g_strdup(*gnet_property->props[65].data.string.def);
    }


    /*
     * PROP_SOCKS_PASS:
     *
     * General data:
     */
    gnet_property->props[66].name = "socks_pass";
    gnet_property->props[66].desc = "Password for proxy";
    gnet_property->props[66].prop_changed_listeners = NULL;
    gnet_property->props[66].save = TRUE;
    gnet_property->props[66].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[66].type               = PROP_TYPE_STRING;
    gnet_property->props[66].data.string.def    = &socks_pass_def;
    gnet_property->props[66].data.string.value  = &socks_pass;
    if (gnet_property->props[66].data.string.def) {
        *gnet_property->props[66].data.string.value =
            g_strdup(*gnet_property->props[66].data.string.def);
    }


    /*
     * PROP_PROXY_IP:
     *
     * General data:
     */
    gnet_property->props[67].name = "proxy_ip";
    gnet_property->props[67].desc = "IP address of the proxy";
    gnet_property->props[67].prop_changed_listeners = NULL;
    gnet_property->props[67].save = TRUE;
    gnet_property->props[67].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[67].type               = PROP_TYPE_IP;
    gnet_property->props[67].data.guint32.def   = &proxy_ip_def;
    gnet_property->props[67].data.guint32.value = &proxy_ip;
    gnet_property->props[67].data.guint32.choices = NULL;
    gnet_property->props[67].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[67].data.guint32.min   = 0x00000000;


    /*
     * PROP_PROXY_PORT:
     *
     * General data:
     */
    gnet_property->props[68].name = "proxy_port";
    gnet_property->props[68].desc = "Port the proxy is listening on";
    gnet_property->props[68].prop_changed_listeners = NULL;
    gnet_property->props[68].save = TRUE;
    gnet_property->props[68].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[68].type               = PROP_TYPE_GUINT32;
    gnet_property->props[68].data.guint32.def   = &proxy_port_def;
    gnet_property->props[68].data.guint32.value = &proxy_port;
    gnet_property->props[68].data.guint32.choices = NULL;
    gnet_property->props[68].data.guint32.max   = 0xFFFF;
    gnet_property->props[68].data.guint32.min   = 0x0000;


    /*
     * PROP_PROXY_PROTOCOL:
     *
     * General data:
     */
    gnet_property->props[69].name = "proxy_protocol";
    gnet_property->props[69].desc = "Protocol the proxy uses";
    gnet_property->props[69].prop_changed_listeners = NULL;
    gnet_property->props[69].save = TRUE;
    gnet_property->props[69].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[69].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[69].data.guint32.def   = &proxy_protocol_def;
    gnet_property->props[69].data.guint32.value = &proxy_protocol;
    gnet_property->props[69].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[69].data.guint32.min   = 0x00000000;
    gnet_property->props[69].data.guint32.choices = proxy_protocol_choices;


    /*
     * PROP_MAX_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[70].name = "max_hosts_cached";
    gnet_property->props[70].desc = "Maximum number of hosts in the regular node catcher";
    gnet_property->props[70].prop_changed_listeners = NULL;
    gnet_property->props[70].save = TRUE;
    gnet_property->props[70].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[70].type               = PROP_TYPE_GUINT32;
    gnet_property->props[70].data.guint32.def   = &max_hosts_cached_def;
    gnet_property->props[70].data.guint32.value = &max_hosts_cached;
    gnet_property->props[70].data.guint32.choices = NULL;
    gnet_property->props[70].data.guint32.max   = 100000;
    gnet_property->props[70].data.guint32.min   = 100;


    /*
     * PROP_HOSTS_IN_CATCHER:
     *
     * General data:
     */
    gnet_property->props[71].name = "hosts_in_catcher";
    gnet_property->props[71].desc = "Current number of hosts in regular node catcher";
    gnet_property->props[71].prop_changed_listeners = NULL;
    gnet_property->props[71].save = FALSE;
    gnet_property->props[71].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[71].type               = PROP_TYPE_GUINT32;
    gnet_property->props[71].data.guint32.def   = &hosts_in_catcher_def;
    gnet_property->props[71].data.guint32.value = &hosts_in_catcher;
    gnet_property->props[71].data.guint32.choices = NULL;
    gnet_property->props[71].data.guint32.max   = 100000;
    gnet_property->props[71].data.guint32.min   = 0;


    /*
     * PROP_HOSTS_IN_ULTRA_CATCHER:
     *
     * General data:
     */
    gnet_property->props[72].name = "hosts_in_ultra_catcher";
    gnet_property->props[72].desc = "Current number of hosts in ultra node catcher";
    gnet_property->props[72].prop_changed_listeners = NULL;
    gnet_property->props[72].save = FALSE;
    gnet_property->props[72].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[72].type               = PROP_TYPE_GUINT32;
    gnet_property->props[72].data.guint32.def   = &hosts_in_ultra_catcher_def;
    gnet_property->props[72].data.guint32.value = &hosts_in_ultra_catcher;
    gnet_property->props[72].data.guint32.choices = NULL;
    gnet_property->props[72].data.guint32.max   = 100000;
    gnet_property->props[72].data.guint32.min   = 0;


    /*
     * PROP_MAX_ULTRA_HOSTS_CACHED:
     *
     * General data:
     */
    gnet_property->props[73].name = "max_ultra_hosts_cached";
    gnet_property->props[73].desc = "Maximum number of hosts in the ultra node catcher";
    gnet_property->props[73].prop_changed_listeners = NULL;
    gnet_property->props[73].save = TRUE;
    gnet_property->props[73].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[73].type               = PROP_TYPE_GUINT32;
    gnet_property->props[73].data.guint32.def   = &max_ultra_hosts_cached_def;
    gnet_property->props[73].data.guint32.value = &max_ultra_hosts_cached;
    gnet_property->props[73].data.guint32.choices = NULL;
    gnet_property->props[73].data.guint32.max   = 100000;
    gnet_property->props[73].data.guint32.min   = 100;


    /*
     * PROP_MAX_HIGH_TTL_MSG:
     *
     * General data:
     */
    gnet_property->props[74].name = "max_high_ttl_msg";
    gnet_property->props[74].desc = "Amount of tolerable messages above hard TTL limit per node. See also MAX_HIGH_TTL_RADIUS";
    gnet_property->props[74].prop_changed_listeners = NULL;
    gnet_property->props[74].save = TRUE;
    gnet_property->props[74].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[74].type               = PROP_TYPE_GUINT32;
    gnet_property->props[74].data.guint32.def   = &max_high_ttl_msg_def;
    gnet_property->props[74].data.guint32.value = &max_high_ttl_msg;
    gnet_property->props[74].data.guint32.choices = NULL;
    gnet_property->props[74].data.guint32.max   = 10000;
    gnet_property->props[74].data.guint32.min   = 0;


    /*
     * PROP_MAX_HIGH_TTL_RADIUS:
     *
     * General data:
     */
    gnet_property->props[75].name = "max_high_ttl_radius";
    gnet_property->props[75].desc = "Hop radius for counting high TTL limit messages (# hops lower than...) See also MAX_HIGH_TTL_MSG";
    gnet_property->props[75].prop_changed_listeners = NULL;
    gnet_property->props[75].save = TRUE;
    gnet_property->props[75].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[75].type               = PROP_TYPE_GUINT32;
    gnet_property->props[75].data.guint32.def   = &max_high_ttl_radius_def;
    gnet_property->props[75].data.guint32.value = &max_high_ttl_radius;
    gnet_property->props[75].data.guint32.choices = NULL;
    gnet_property->props[75].data.guint32.max   = 10;
    gnet_property->props[75].data.guint32.min   = 0;


    /*
     * PROP_BW_HTTP_IN:
     *
     * General data:
     */
    gnet_property->props[76].name = "input_bandwidth";
    gnet_property->props[76].desc = "Bandwidth limit for incoming HTTP traffic in bytes/sec";
    gnet_property->props[76].prop_changed_listeners = NULL;
    gnet_property->props[76].save = TRUE;
    gnet_property->props[76].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[76].type               = PROP_TYPE_GUINT32;
    gnet_property->props[76].data.guint32.def   = &bw_http_in_def;
    gnet_property->props[76].data.guint32.value = &bw_http_in;
    gnet_property->props[76].data.guint32.choices = NULL;
    gnet_property->props[76].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[76].data.guint32.min   = 1024;


    /*
     * PROP_BW_HTTP_OUT:
     *
     * General data:
     */
    gnet_property->props[77].name = "output_bandwidth";
    gnet_property->props[77].desc = "Bandwidth limit for outgoing HTTP traffic in bytes/sec";
    gnet_property->props[77].prop_changed_listeners = NULL;
    gnet_property->props[77].save = TRUE;
    gnet_property->props[77].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[77].type               = PROP_TYPE_GUINT32;
    gnet_property->props[77].data.guint32.def   = &bw_http_out_def;
    gnet_property->props[77].data.guint32.value = &bw_http_out;
    gnet_property->props[77].data.guint32.choices = NULL;
    gnet_property->props[77].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[77].data.guint32.min   = 1024;


    /*
     * PROP_BW_GNET_IN:
     *
     * General data:
     */
    gnet_property->props[78].name = "input_gnet_bandwidth";
    gnet_property->props[78].desc = "Bandwidth limit for incoming gNet traffic in bytes/sec";
    gnet_property->props[78].prop_changed_listeners = NULL;
    gnet_property->props[78].save = TRUE;
    gnet_property->props[78].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[78].type               = PROP_TYPE_GUINT32;
    gnet_property->props[78].data.guint32.def   = &bw_gnet_in_def;
    gnet_property->props[78].data.guint32.value = &bw_gnet_in;
    gnet_property->props[78].data.guint32.choices = NULL;
    gnet_property->props[78].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[78].data.guint32.min   = 1024;


    /*
     * PROP_BW_GNET_OUT:
     *
     * General data:
     */
    gnet_property->props[79].name = "output_gnet_bandwidth";
    gnet_property->props[79].desc = "Bandwidth limit for outgoing gNet traffic in bytes/sec";
    gnet_property->props[79].prop_changed_listeners = NULL;
    gnet_property->props[79].save = TRUE;
    gnet_property->props[79].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[79].type               = PROP_TYPE_GUINT32;
    gnet_property->props[79].data.guint32.def   = &bw_gnet_out_def;
    gnet_property->props[79].data.guint32.value = &bw_gnet_out;
    gnet_property->props[79].data.guint32.choices = NULL;
    gnet_property->props[79].data.guint32.max   = BS_BW_MAX;
    gnet_property->props[79].data.guint32.min   = 1024;


    /*
     * PROP_SEARCH_QUERIES_FORWARD_SIZE:
     *
     * General data:
     */
    gnet_property->props[80].name = "search_queries_forward_size";
    gnet_property->props[80].desc = "Maximum size of search queries messages we forward to others  (in bytes)";
    gnet_property->props[80].prop_changed_listeners = NULL;
    gnet_property->props[80].save = TRUE;
    gnet_property->props[80].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[80].type               = PROP_TYPE_GUINT32;
    gnet_property->props[80].data.guint32.def   = &search_queries_forward_size_def;
    gnet_property->props[80].data.guint32.value = &search_queries_forward_size;
    gnet_property->props[80].data.guint32.choices = NULL;
    gnet_property->props[80].data.guint32.max   = 65536;
    gnet_property->props[80].data.guint32.min   = 64;


    /*
     * PROP_SEARCH_QUERIES_KICK_SIZE:
     *
     * General data:
     */
    gnet_property->props[81].name = "search_queries_kick_size";
    gnet_property->props[81].desc = "Maximum size of search queries messages we allow, otherwise close the connection (in bytes)";
    gnet_property->props[81].prop_changed_listeners = NULL;
    gnet_property->props[81].save = TRUE;
    gnet_property->props[81].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[81].type               = PROP_TYPE_GUINT32;
    gnet_property->props[81].data.guint32.def   = &search_queries_kick_size_def;
    gnet_property->props[81].data.guint32.value = &search_queries_kick_size;
    gnet_property->props[81].data.guint32.choices = NULL;
    gnet_property->props[81].data.guint32.max   = 65536;
    gnet_property->props[81].data.guint32.min   = 128;


    /*
     * PROP_SEARCH_ANSWERS_FORWARD_SIZE:
     *
     * General data:
     */
    gnet_property->props[82].name = "search_answers_forward_size";
    gnet_property->props[82].desc = "Maximum size of search answers messages we forward to others (in bytes)";
    gnet_property->props[82].prop_changed_listeners = NULL;
    gnet_property->props[82].save = TRUE;
    gnet_property->props[82].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[82].type               = PROP_TYPE_GUINT32;
    gnet_property->props[82].data.guint32.def   = &search_answers_forward_size_def;
    gnet_property->props[82].data.guint32.value = &search_answers_forward_size;
    gnet_property->props[82].data.guint32.choices = NULL;
    gnet_property->props[82].data.guint32.max   = 65536;
    gnet_property->props[82].data.guint32.min   = 2048;


    /*
     * PROP_SEARCH_ANSWERS_KICK_SIZE:
     *
     * General data:
     */
    gnet_property->props[83].name = "search_answers_kick_size";
    gnet_property->props[83].desc = "Maximum size of search answers messages we allow, otherwise close the connection (in bytes)";
    gnet_property->props[83].prop_changed_listeners = NULL;
    gnet_property->props[83].save = TRUE;
    gnet_property->props[83].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[83].type               = PROP_TYPE_GUINT32;
    gnet_property->props[83].data.guint32.def   = &search_answers_kick_size_def;
    gnet_property->props[83].data.guint32.value = &search_answers_kick_size;
    gnet_property->props[83].data.guint32.choices = NULL;
    gnet_property->props[83].data.guint32.max   = 65536;
    gnet_property->props[83].data.guint32.min   = 2048;


    /*
     * PROP_OTHER_MESSAGES_KICK_SIZE:
     *
     * General data:
     */
    gnet_property->props[84].name = "other_messages_kick_size";
    gnet_property->props[84].desc = "Maximum size of unknown messages we allow, otherwise close the connection (in bytes)";
    gnet_property->props[84].prop_changed_listeners = NULL;
    gnet_property->props[84].save = TRUE;
    gnet_property->props[84].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[84].type               = PROP_TYPE_GUINT32;
    gnet_property->props[84].data.guint32.def   = &other_messages_kick_size_def;
    gnet_property->props[84].data.guint32.value = &other_messages_kick_size;
    gnet_property->props[84].data.guint32.choices = NULL;
    gnet_property->props[84].data.guint32.max   = 65536;
    gnet_property->props[84].data.guint32.min   = 256;


    /*
     * PROP_HOPS_RANDOM_FACTOR:
     *
     * General data:
     */
    gnet_property->props[85].name = "hops_random_factor";
    gnet_property->props[85].desc = "Random factor for the hops field in search packets we send between 0 and 3 inclusive)";
    gnet_property->props[85].prop_changed_listeners = NULL;
    gnet_property->props[85].save = TRUE;
    gnet_property->props[85].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[85].type               = PROP_TYPE_GUINT32;
    gnet_property->props[85].data.guint32.def   = &hops_random_factor_def;
    gnet_property->props[85].data.guint32.value = &hops_random_factor;
    gnet_property->props[85].data.guint32.choices = NULL;
    gnet_property->props[85].data.guint32.max   = 3;
    gnet_property->props[85].data.guint32.min   = 0;


    /*
     * PROP_SEND_PUSHES:
     *
     * General data:
     */
    gnet_property->props[86].name = "send_pushes";
    gnet_property->props[86].desc = "Whether or not to send push requests.  If you are firewalled, gtk-gnutella will never send push requests anyway.  If you don't let gtk-gnutella send pushes, it will not show search results that would require a push.";
    gnet_property->props[86].prop_changed_listeners = NULL;
    gnet_property->props[86].save = TRUE;
    gnet_property->props[86].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[86].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[86].data.boolean.def   = &send_pushes_def;
    gnet_property->props[86].data.boolean.value = &send_pushes;


    /*
     * PROP_MIN_DUP_MSG:
     *
     * General data:
     */
    gnet_property->props[87].name = "min_dup_msg";
    gnet_property->props[87].desc = "Minimum amount of dup messages to enable kicking, per node (also see [min_dup_ratio])";
    gnet_property->props[87].prop_changed_listeners = NULL;
    gnet_property->props[87].save = TRUE;
    gnet_property->props[87].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[87].type               = PROP_TYPE_GUINT32;
    gnet_property->props[87].data.guint32.def   = &min_dup_msg_def;
    gnet_property->props[87].data.guint32.value = &min_dup_msg;
    gnet_property->props[87].data.guint32.choices = NULL;
    gnet_property->props[87].data.guint32.max   = 99;
    gnet_property->props[87].data.guint32.min   = 1;


    /*
     * PROP_MIN_DUP_RATIO:
     *
     * General data:
     */
    gnet_property->props[88].name = "min_dup_ratio";
    gnet_property->props[88].desc = "Minimum ratio of dups on received messages, per node (between 0.00 and 100.00) (also see [min_dup_msg]) Note: the value is stored between 0 (0.0) and 10000 (100.0) in the config file";
    gnet_property->props[88].prop_changed_listeners = NULL;
    gnet_property->props[88].save = TRUE;
    gnet_property->props[88].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[88].type               = PROP_TYPE_GUINT32;
    gnet_property->props[88].data.guint32.def   = &min_dup_ratio_def;
    gnet_property->props[88].data.guint32.value = &min_dup_ratio;
    gnet_property->props[88].data.guint32.choices = NULL;
    gnet_property->props[88].data.guint32.max   = 10000;
    gnet_property->props[88].data.guint32.min   = 0;


    /*
     * PROP_SCAN_EXTENSIONS:
     *
     * General data:
     */
    gnet_property->props[89].name = "shared_files_extensions";
    gnet_property->props[89].desc = "Only files with the given extensions will be shared. The special --all-- extension matches all files, even if they don't have any extension.  Use with care.";
    gnet_property->props[89].prop_changed_listeners = NULL;
    gnet_property->props[89].save = TRUE;
    gnet_property->props[89].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[89].type               = PROP_TYPE_STRING;
    gnet_property->props[89].data.string.def    = &scan_extensions_def;
    gnet_property->props[89].data.string.value  = &scan_extensions;
    if (gnet_property->props[89].data.string.def) {
        *gnet_property->props[89].data.string.value =
            g_strdup(*gnet_property->props[89].data.string.def);
    }


    /*
     * PROP_SAVE_FILE_PATH:
     *
     * General data:
     */
    gnet_property->props[90].name = "store_downloading_files_to";
    gnet_property->props[90].desc = "Store incomplete files in this directory";
    gnet_property->props[90].prop_changed_listeners = NULL;
    gnet_property->props[90].save = TRUE;
    gnet_property->props[90].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[90].type               = PROP_TYPE_STRING;
    gnet_property->props[90].data.string.def    = &save_file_path_def;
    gnet_property->props[90].data.string.value  = &save_file_path;
    if (gnet_property->props[90].data.string.def) {
        *gnet_property->props[90].data.string.value =
            g_strdup(*gnet_property->props[90].data.string.def);
    }


    /*
     * PROP_MOVE_FILE_PATH:
     *
     * General data:
     */
    gnet_property->props[91].name = "move_downloading_files_to";
    gnet_property->props[91].desc = "Move complete files to this directory. If this is set to the SAME directory as the incomplete or corrupted files, files will be renamed with a trailing .OK";
    gnet_property->props[91].prop_changed_listeners = NULL;
    gnet_property->props[91].save = TRUE;
    gnet_property->props[91].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[91].type               = PROP_TYPE_STRING;
    gnet_property->props[91].data.string.def    = &move_file_path_def;
    gnet_property->props[91].data.string.value  = &move_file_path;
    if (gnet_property->props[91].data.string.def) {
        *gnet_property->props[91].data.string.value =
            g_strdup(*gnet_property->props[91].data.string.def);
    }


    /*
     * PROP_BAD_FILE_PATH:
     *
     * General data:
     */
    gnet_property->props[92].name = "move_corrupted_files_to";
    gnet_property->props[92].desc = "Move corrupted downloaded files in this directory. If this is set to the SAME directory as the incomplete or completed files, files will be renamed with a trailing .BAD";
    gnet_property->props[92].prop_changed_listeners = NULL;
    gnet_property->props[92].save = TRUE;
    gnet_property->props[92].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[92].type               = PROP_TYPE_STRING;
    gnet_property->props[92].data.string.def    = &bad_file_path_def;
    gnet_property->props[92].data.string.value  = &bad_file_path;
    if (gnet_property->props[92].data.string.def) {
        *gnet_property->props[92].data.string.value =
            g_strdup(*gnet_property->props[92].data.string.def);
    }


    /*
     * PROP_SHARED_DIRS_PATHS:
     *
     * General data:
     */
    gnet_property->props[93].name = "shared_dirs";
    gnet_property->props[93].desc = "Directories which contain shared files";
    gnet_property->props[93].prop_changed_listeners = NULL;
    gnet_property->props[93].save = TRUE;
    gnet_property->props[93].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[93].type               = PROP_TYPE_STRING;
    gnet_property->props[93].data.string.def    = &shared_dirs_paths_def;
    gnet_property->props[93].data.string.value  = &shared_dirs_paths;
    if (gnet_property->props[93].data.string.def) {
        *gnet_property->props[93].data.string.value =
            g_strdup(*gnet_property->props[93].data.string.def);
    }


    /*
     * PROP_LOCAL_NETMASKS_STRING:
     *
     * General data:
     */
    gnet_property->props[94].name = "local_netmasks";
    gnet_property->props[94].desc = "List of networks considered local.  This is a list of IP addresses, separated by ';'.  The IP address can be given out fully, as in 192.168.0.1, or be optionally followed by '/' and a network mask prefix length. For instance, 192.168.0.1/24 would represent the whole 192.168.0.* network.";
    gnet_property->props[94].prop_changed_listeners = NULL;
    gnet_property->props[94].save = TRUE;
    gnet_property->props[94].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[94].type               = PROP_TYPE_STRING;
    gnet_property->props[94].data.string.def    = &local_netmasks_string_def;
    gnet_property->props[94].data.string.value  = &local_netmasks_string;
    if (gnet_property->props[94].data.string.def) {
        *gnet_property->props[94].data.string.value =
            g_strdup(*gnet_property->props[94].data.string.def);
    }


    /*
     * PROP_TOTAL_DOWNLOADS:
     *
     * General data:
     */
    gnet_property->props[95].name = "total_downloads";
    gnet_property->props[95].desc = "Total number of completed downloads in this session";
    gnet_property->props[95].prop_changed_listeners = NULL;
    gnet_property->props[95].save = FALSE;
    gnet_property->props[95].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[95].type               = PROP_TYPE_GUINT32;
    gnet_property->props[95].data.guint32.def   = &total_downloads_def;
    gnet_property->props[95].data.guint32.value = &total_downloads;
    gnet_property->props[95].data.guint32.choices = NULL;
    gnet_property->props[95].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[95].data.guint32.min   = 0x00000000;


    /*
     * PROP_TOTAL_UPLOADS:
     *
     * General data:
     */
    gnet_property->props[96].name = "total_uploads";
    gnet_property->props[96].desc = "Total number of completed uploads in this session";
    gnet_property->props[96].prop_changed_listeners = NULL;
    gnet_property->props[96].save = FALSE;
    gnet_property->props[96].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[96].type               = PROP_TYPE_GUINT32;
    gnet_property->props[96].data.guint32.def   = &total_uploads_def;
    gnet_property->props[96].data.guint32.value = &total_uploads;
    gnet_property->props[96].data.guint32.choices = NULL;
    gnet_property->props[96].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[96].data.guint32.min   = 0x00000000;


    /*
     * PROP_GUID:
     *
     * General data:
     */
    gnet_property->props[97].name = "guid";
    gnet_property->props[97].desc = "Global Unique IDentifier of this node";
    gnet_property->props[97].prop_changed_listeners = NULL;
    gnet_property->props[97].save = TRUE;
    gnet_property->props[97].vector_size = 16;

    /* Type specific data: */
    gnet_property->props[97].type               = PROP_TYPE_STORAGE;
    gnet_property->props[97].data.storage.value = guid;
    memset(guid, 0, gnet_property->props[97].vector_size);


    /*
     * PROP_USE_SWARMING:
     *
     * General data:
     */
    gnet_property->props[98].name = "use_swarming";
    gnet_property->props[98].desc = "Wether or not to use swarming (recommended = YES)";
    gnet_property->props[98].prop_changed_listeners = NULL;
    gnet_property->props[98].save = TRUE;
    gnet_property->props[98].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[98].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[98].data.boolean.def   = &use_swarming_def;
    gnet_property->props[98].data.boolean.value = &use_swarming;


    /*
     * PROP_USE_AGGRESSIVE_SWARMING:
     *
     * General data:
     */
    gnet_property->props[99].name = "use_aggressive_swarming";
    gnet_property->props[99].desc = "Whether or not to launch competing downloads when swarming and there are many sources available with a few chunks left.";
    gnet_property->props[99].prop_changed_listeners = NULL;
    gnet_property->props[99].save = TRUE;
    gnet_property->props[99].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[99].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[99].data.boolean.def   = &use_aggressive_swarming_def;
    gnet_property->props[99].data.boolean.value = &use_aggressive_swarming;


    /*
     * PROP_DL_MINCHUNKSIZE:
     *
     * General data:
     */
    gnet_property->props[100].name = "dl_minchunksize";
    gnet_property->props[100].desc = "Minimum chunk size when swarming.  This is only a hint as gtk-gnutella will download less if you only have a few bytes to get for a file...";
    gnet_property->props[100].prop_changed_listeners = NULL;
    gnet_property->props[100].save = TRUE;
    gnet_property->props[100].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[100].type               = PROP_TYPE_GUINT32;
    gnet_property->props[100].data.guint32.def   = &dl_minchunksize_def;
    gnet_property->props[100].data.guint32.value = &dl_minchunksize;
    gnet_property->props[100].data.guint32.choices = NULL;
    gnet_property->props[100].data.guint32.max   = 100*1024*1024;
    gnet_property->props[100].data.guint32.min   = 64*1024;


    /*
     * PROP_DL_MAXCHUNKSIZE:
     *
     * General data:
     */
    gnet_property->props[101].name = "dl_maxchunksize";
    gnet_property->props[101].desc = "Maximum chunk size when swarming";
    gnet_property->props[101].prop_changed_listeners = NULL;
    gnet_property->props[101].save = TRUE;
    gnet_property->props[101].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[101].type               = PROP_TYPE_GUINT32;
    gnet_property->props[101].data.guint32.def   = &dl_maxchunksize_def;
    gnet_property->props[101].data.guint32.value = &dl_maxchunksize;
    gnet_property->props[101].data.guint32.choices = NULL;
    gnet_property->props[101].data.guint32.max   = 1000*1024*1024;
    gnet_property->props[101].data.guint32.min   = 64*1024;


    /*
     * PROP_AUTO_DOWNLOAD_IDENTICAL:
     *
     * General data:
     */
    gnet_property->props[102].name = "auto_download_identical";
    gnet_property->props[102].desc = "Wether or not to automatically queue search results that match a file in the download queue";
    gnet_property->props[102].prop_changed_listeners = NULL;
    gnet_property->props[102].save = TRUE;
    gnet_property->props[102].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[102].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[102].data.boolean.def   = &auto_download_identical_def;
    gnet_property->props[102].data.boolean.value = &auto_download_identical;


    /*
     * PROP_STRICT_SHA1_MATCHING:
     *
     * General data:
     */
    gnet_property->props[103].name = "strict_sha1_matching";
    gnet_property->props[103].desc = "When enabled, SHA1s must match. Otherwise, name and size will be sufficient";
    gnet_property->props[103].prop_changed_listeners = NULL;
    gnet_property->props[103].save = TRUE;
    gnet_property->props[103].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[103].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[103].data.boolean.def   = &strict_sha1_matching_def;
    gnet_property->props[103].data.boolean.value = &strict_sha1_matching;


    /*
     * PROP_USE_FUZZY_MATCHING:
     *
     * General data:
     */
    gnet_property->props[104].name = "use_fuzzy_matching";
    gnet_property->props[104].desc = "Use fuzzy file name matching (recommended = NO; only rely on SHA1 matching to be safe)";
    gnet_property->props[104].prop_changed_listeners = NULL;
    gnet_property->props[104].save = TRUE;
    gnet_property->props[104].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[104].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[104].data.boolean.def   = &use_fuzzy_matching_def;
    gnet_property->props[104].data.boolean.value = &use_fuzzy_matching;


    /*
     * PROP_FUZZY_THRESHOLD:
     *
     * General data:
     */
    gnet_property->props[105].name = "fuzzy_threshold";
    gnet_property->props[105].desc = "Fuzziness threshold for filename matching (higher = stricter). A value of 100 means the filenames must be 100% identical.  A value of 0 means any two filenames will always be considered to be identical.  The minimum is 50%.";
    gnet_property->props[105].prop_changed_listeners = NULL;
    gnet_property->props[105].save = TRUE;
    gnet_property->props[105].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[105].type               = PROP_TYPE_GUINT32;
    gnet_property->props[105].data.guint32.def   = &fuzzy_threshold_def;
    gnet_property->props[105].data.guint32.value = &fuzzy_threshold;
    gnet_property->props[105].data.guint32.choices = NULL;
    gnet_property->props[105].data.guint32.max   = 100;
    gnet_property->props[105].data.guint32.min   = 50;


    /*
     * PROP_IS_FIREWALLED:
     *
     * General data:
     */
    gnet_property->props[106].name = "is_firewalled";
    gnet_property->props[106].desc = "Whether gtk-gnutella thinks we're currently firewalled";
    gnet_property->props[106].prop_changed_listeners = NULL;
    gnet_property->props[106].save = TRUE;
    gnet_property->props[106].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[106].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[106].data.boolean.def   = &is_firewalled_def;
    gnet_property->props[106].data.boolean.value = &is_firewalled;


    /*
     * PROP_IS_INET_CONNECTED:
     *
     * General data:
     */
    gnet_property->props[107].name = "is_inet_connected";
    gnet_property->props[107].desc = "Whether gtk-gnutella thinks it's connected to the Internet";
    gnet_property->props[107].prop_changed_listeners = NULL;
    gnet_property->props[107].save = FALSE;
    gnet_property->props[107].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[107].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[107].data.boolean.def   = &is_inet_connected_def;
    gnet_property->props[107].data.boolean.value = &is_inet_connected;


    /*
     * PROP_GNET_COMPACT_QUERY:
     *
     * General data:
     */
    gnet_property->props[108].name = "gnet_compact_query";
    gnet_property->props[108].desc = "Remove unnecessary ballast from query string before processing or forwarding them. Reduces traffic at the cost of little CPU time";
    gnet_property->props[108].prop_changed_listeners = NULL;
    gnet_property->props[108].save = TRUE;
    gnet_property->props[108].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[108].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[108].data.boolean.def   = &gnet_compact_query_def;
    gnet_property->props[108].data.boolean.value = &gnet_compact_query;


    /*
     * PROP_DOWNLOAD_OPTIMISTIC_START:
     *
     * General data:
     */
    gnet_property->props[109].name = "download_optimistic_start";
    gnet_property->props[109].desc = "Also use sources that don't provide a SHA1 value for the first chunk of a file. This dramatically reduces the 'No URN on server' messages, but may result in overlap problems later if the first chunk was actually from a different file. Use with caution.";
    gnet_property->props[109].prop_changed_listeners = NULL;
    gnet_property->props[109].save = TRUE;
    gnet_property->props[109].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[109].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[109].data.boolean.def   = &download_optimistic_start_def;
    gnet_property->props[109].data.boolean.value = &download_optimistic_start;


    /*
     * PROP_MARK_IGNORED:
     *
     * General data:
     */
    gnet_property->props[110].name = "mark_ignored";
    gnet_property->props[110].desc = "Mark files that would be ignored when downloaded. This uses a little additional CPU power so it's off by default. If you don't have a very slow box, you might want to turn this on.";
    gnet_property->props[110].prop_changed_listeners = NULL;
    gnet_property->props[110].save = TRUE;
    gnet_property->props[110].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[110].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[110].data.boolean.def   = &mark_ignored_def;
    gnet_property->props[110].data.boolean.value = &mark_ignored;


    /*
     * PROP_LIBRARY_REBUILDING:
     *
     * General data:
     */
    gnet_property->props[111].name = "library_rebuilding";
    gnet_property->props[111].desc = "Whether gtk-gnutella is currently rebuilding its library in the background";
    gnet_property->props[111].prop_changed_listeners = NULL;
    gnet_property->props[111].save = FALSE;
    gnet_property->props[111].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[111].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[111].data.boolean.def   = &library_rebuilding_def;
    gnet_property->props[111].data.boolean.value = &library_rebuilding;


    /*
     * PROP_SHA1_REBUILDING:
     *
     * General data:
     */
    gnet_property->props[112].name = "sha1_rebuilding";
    gnet_property->props[112].desc = "Whether gtk-gnutella is currently computing SHA1 of shared files in the background";
    gnet_property->props[112].prop_changed_listeners = NULL;
    gnet_property->props[112].save = FALSE;
    gnet_property->props[112].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[112].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[112].data.boolean.def   = &sha1_rebuilding_def;
    gnet_property->props[112].data.boolean.value = &sha1_rebuilding;


    /*
     * PROP_SHA1_VERIFYING:
     *
     * General data:
     */
    gnet_property->props[113].name = "sha1_verifying";
    gnet_property->props[113].desc = "Whether gtk-gnutella is currently verifying SHA1 of downloaded files in the background";
    gnet_property->props[113].prop_changed_listeners = NULL;
    gnet_property->props[113].save = FALSE;
    gnet_property->props[113].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[113].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[113].data.boolean.def   = &sha1_verifying_def;
    gnet_property->props[113].data.boolean.value = &sha1_verifying;


    /*
     * PROP_FILE_MOVING:
     *
     * General data:
     */
    gnet_property->props[114].name = "file_moving";
    gnet_property->props[114].desc = "Whether gtk-gnutella is currently moving files accross filesystems or simply copying in the background";
    gnet_property->props[114].prop_changed_listeners = NULL;
    gnet_property->props[114].save = FALSE;
    gnet_property->props[114].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[114].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[114].data.boolean.def   = &file_moving_def;
    gnet_property->props[114].data.boolean.value = &file_moving;


    /*
     * PROP_PREFER_COMPRESSED_GNET:
     *
     * General data:
     */
    gnet_property->props[115].name = "prefer_compressed_gnet";
    gnet_property->props[115].desc = "If active, only compressed incoming connections are allowed after the minimum number of connections has been established. Always allows for one non-compressed connection.";
    gnet_property->props[115].prop_changed_listeners = NULL;
    gnet_property->props[115].save = TRUE;
    gnet_property->props[115].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[115].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[115].data.boolean.def   = &prefer_compressed_gnet_def;
    gnet_property->props[115].data.boolean.value = &prefer_compressed_gnet;


    /*
     * PROP_ONLINE_MODE:
     *
     * General data:
     */
    gnet_property->props[116].name = "online_mode";
    gnet_property->props[116].desc = "If deactivated only uploads and downloads will continue. All gNet connections are disabled/terminated.";
    gnet_property->props[116].prop_changed_listeners = NULL;
    gnet_property->props[116].save = TRUE;
    gnet_property->props[116].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[116].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[116].data.boolean.def   = &online_mode_def;
    gnet_property->props[116].data.boolean.value = &online_mode;


    /*
     * PROP_LIB_DEBUG:
     *
     * General data:
     */
    gnet_property->props[117].name = "lib_debug";
    gnet_property->props[117].desc = "Debug level for code shared between gui and core";
    gnet_property->props[117].prop_changed_listeners = NULL;
    gnet_property->props[117].save = TRUE;
    gnet_property->props[117].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[117].type               = PROP_TYPE_GUINT32;
    gnet_property->props[117].data.guint32.def   = &lib_debug_def;
    gnet_property->props[117].data.guint32.value = &lib_debug;
    gnet_property->props[117].data.guint32.choices = NULL;
    gnet_property->props[117].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[117].data.guint32.min   = 0x00000000;


    /*
     * PROP_DOWNLOAD_REQUIRE_URN:
     *
     * General data:
     */
    gnet_property->props[118].name = "download_require_urn";
    gnet_property->props[118].desc = "Whether gtk-gnutella should make sure the server confirms the URN of the file we're requesting when it is known locally and a traditional request by name is used (i.e. gtk-gnutella is not issueing a /uri-res/N2R? request).  When set, it supersedes the optimistic first chunk setting.";
    gnet_property->props[118].prop_changed_listeners = NULL;
    gnet_property->props[118].save = TRUE;
    gnet_property->props[118].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[118].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[118].data.boolean.def   = &download_require_urn_def;
    gnet_property->props[118].data.boolean.value = &download_require_urn;


    /*
     * PROP_DOWNLOAD_REQUIRE_SERVER_NAME:
     *
     * General data:
     */
    gnet_property->props[119].name = "download_require_server_name";
    gnet_property->props[119].desc = "Whether gtk-gnutella should make sure the server gives us back a non-empty identifying token.";
    gnet_property->props[119].prop_changed_listeners = NULL;
    gnet_property->props[119].save = TRUE;
    gnet_property->props[119].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[119].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[119].data.boolean.def   = &download_require_server_name_def;
    gnet_property->props[119].data.boolean.value = &download_require_server_name;


    /*
     * PROP_FORCE_ULTRAPEER:
     *
     * General data:
     */
    gnet_property->props[120].name = "force_ultrapeer";
    gnet_property->props[120].desc = "Whether gtk-gnutella should start up as an Ultrapeer regardless of whether the node is capable of handling it.  This setting is only valid for the first hour (debugging only).";
    gnet_property->props[120].prop_changed_listeners = NULL;
    gnet_property->props[120].save = TRUE;
    gnet_property->props[120].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[120].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[120].data.boolean.def   = &force_ultrapeer_def;
    gnet_property->props[120].data.boolean.value = &force_ultrapeer;


    /*
     * PROP_FORCE_LEAF:
     *
     * General data:
     */
    gnet_property->props[121].name = "force_leaf";
    gnet_property->props[121].desc = "Whether gtk-gnutella should always act as a leaf node, regardless of whether the node is capable of becoming an Ultrapeer.";
    gnet_property->props[121].prop_changed_listeners = NULL;
    gnet_property->props[121].save = TRUE;
    gnet_property->props[121].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[121].type               = PROP_TYPE_BOOLEAN;
    gnet_property->props[121].data.boolean.def   = &force_leaf_def;
    gnet_property->props[121].data.boolean.value = &force_leaf;


    /*
     * PROP_MAX_ULTRAPEERS:
     *
     * General data:
     */
    gnet_property->props[122].name = "max_ultrapeers";
    gnet_property->props[122].desc = "Maximum amount of Ultrapeers we should connect to as a leaf.";
    gnet_property->props[122].prop_changed_listeners = NULL;
    gnet_property->props[122].save = TRUE;
    gnet_property->props[122].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[122].type               = PROP_TYPE_GUINT32;
    gnet_property->props[122].data.guint32.def   = &max_ultrapeers_def;
    gnet_property->props[122].data.guint32.value = &max_ultrapeers;
    gnet_property->props[122].data.guint32.choices = NULL;
    gnet_property->props[122].data.guint32.max   = 4;
    gnet_property->props[122].data.guint32.min   = 1;


    /*
     * PROP_MAX_LEAVES:
     *
     * General data:
     */
    gnet_property->props[123].name = "max_leaves";
    gnet_property->props[123].desc = "Maximum amount of leaves we can accept.";
    gnet_property->props[123].prop_changed_listeners = NULL;
    gnet_property->props[123].save = TRUE;
    gnet_property->props[123].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[123].type               = PROP_TYPE_GUINT32;
    gnet_property->props[123].data.guint32.def   = &max_leaves_def;
    gnet_property->props[123].data.guint32.value = &max_leaves;
    gnet_property->props[123].data.guint32.choices = NULL;
    gnet_property->props[123].data.guint32.max   = 1000;
    gnet_property->props[123].data.guint32.min   = 25;


    /*
     * PROP_CURRENT_PEERMODE:
     *
     * General data:
     */
    gnet_property->props[124].name = "current_peermode";
    gnet_property->props[124].desc = "Current peer mode for gtk-gnutella";
    gnet_property->props[124].prop_changed_listeners = NULL;
    gnet_property->props[124].save = TRUE;
    gnet_property->props[124].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[124].type               = PROP_TYPE_MULTICHOICE;
    gnet_property->props[124].data.guint32.def   = &current_peermode_def;
    gnet_property->props[124].data.guint32.value = &current_peermode;
    gnet_property->props[124].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[124].data.guint32.min   = 0x00000000;
    gnet_property->props[124].data.guint32.choices = current_peermode_choices;


    /*
     * PROP_SYS_NOFILE:
     *
     * General data:
     */
    gnet_property->props[125].name = "sys_nofile";
    gnet_property->props[125].desc = "How many file descriptors a process can open.";
    gnet_property->props[125].prop_changed_listeners = NULL;
    gnet_property->props[125].save = FALSE;
    gnet_property->props[125].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[125].type               = PROP_TYPE_GUINT32;
    gnet_property->props[125].data.guint32.def   = &sys_nofile_def;
    gnet_property->props[125].data.guint32.value = &sys_nofile;
    gnet_property->props[125].data.guint32.choices = NULL;
    gnet_property->props[125].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[125].data.guint32.min   = 0x00000000;


    /*
     * PROP_SYS_PHYSMEM:
     *
     * General data:
     */
    gnet_property->props[126].name = "sys_physmem";
    gnet_property->props[126].desc = "How many KB of physical memory is available.";
    gnet_property->props[126].prop_changed_listeners = NULL;
    gnet_property->props[126].save = FALSE;
    gnet_property->props[126].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[126].type               = PROP_TYPE_GUINT32;
    gnet_property->props[126].data.guint32.def   = &sys_physmem_def;
    gnet_property->props[126].data.guint32.value = &sys_physmem;
    gnet_property->props[126].data.guint32.choices = NULL;
    gnet_property->props[126].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[126].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_QUEUE_COUNT:
     *
     * General data:
     */
    gnet_property->props[127].name = "dl_queue_count";
    gnet_property->props[127].desc = "How many downloads are currently held in the queue.";
    gnet_property->props[127].prop_changed_listeners = NULL;
    gnet_property->props[127].save = FALSE;
    gnet_property->props[127].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[127].type               = PROP_TYPE_GUINT32;
    gnet_property->props[127].data.guint32.def   = &dl_queue_count_def;
    gnet_property->props[127].data.guint32.value = &dl_queue_count;
    gnet_property->props[127].data.guint32.choices = NULL;
    gnet_property->props[127].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[127].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_RUNNING_COUNT:
     *
     * General data:
     */
    gnet_property->props[128].name = "dl_running_count";
    gnet_property->props[128].desc = "How many downloads are currently running (downloading / connecting).";
    gnet_property->props[128].prop_changed_listeners = NULL;
    gnet_property->props[128].save = FALSE;
    gnet_property->props[128].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[128].type               = PROP_TYPE_GUINT32;
    gnet_property->props[128].data.guint32.def   = &dl_running_count_def;
    gnet_property->props[128].data.guint32.value = &dl_running_count;
    gnet_property->props[128].data.guint32.choices = NULL;
    gnet_property->props[128].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[128].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_QALIVE_COUNT:
     *
     * General data:
     */
    gnet_property->props[129].name = "dl_qalive_count";
    gnet_property->props[129].desc = "How many queued downloads are currently responsive (remote servent answering requests).";
    gnet_property->props[129].prop_changed_listeners = NULL;
    gnet_property->props[129].save = FALSE;
    gnet_property->props[129].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[129].type               = PROP_TYPE_GUINT32;
    gnet_property->props[129].data.guint32.def   = &dl_qalive_count_def;
    gnet_property->props[129].data.guint32.value = &dl_qalive_count;
    gnet_property->props[129].data.guint32.choices = NULL;
    gnet_property->props[129].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[129].data.guint32.min   = 0x00000000;


    /*
     * PROP_DL_BYTE_COUNT:
     *
     * General data:
     */
    gnet_property->props[130].name = "dl_byte_count";
    gnet_property->props[130].desc = "Amount of bytes downloaded so far, HTTP headers not withstanding.";
    gnet_property->props[130].prop_changed_listeners = NULL;
    gnet_property->props[130].save = FALSE;
    gnet_property->props[130].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[130].type               = PROP_TYPE_GUINT32;
    gnet_property->props[130].data.guint32.def   = &dl_byte_count_def;
    gnet_property->props[130].data.guint32.value = &dl_byte_count;
    gnet_property->props[130].data.guint32.choices = NULL;
    gnet_property->props[130].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[130].data.guint32.min   = 0x00000000;


    /*
     * PROP_UL_BYTE_COUNT:
     *
     * General data:
     */
    gnet_property->props[131].name = "ul_byte_count";
    gnet_property->props[131].desc = "Amount of bytes uploaded so far, HTTP headers not withstanding.";
    gnet_property->props[131].prop_changed_listeners = NULL;
    gnet_property->props[131].save = FALSE;
    gnet_property->props[131].vector_size = 1;

    /* Type specific data: */
    gnet_property->props[131].type               = PROP_TYPE_GUINT32;
    gnet_property->props[131].data.guint32.def   = &ul_byte_count_def;
    gnet_property->props[131].data.guint32.value = &ul_byte_count;
    gnet_property->props[131].data.guint32.choices = NULL;
    gnet_property->props[131].data.guint32.max   = 0xFFFFFFFF;
    gnet_property->props[131].data.guint32.min   = 0x00000000;
    return gnet_property;
}

/*
 * gnet_prop_shutdown:
 *
 * Free memory allocated by the property set.
 */
void gnet_prop_shutdown(void) {
    gint n;

    for (n = 0; n < GNET_PROPERTY_NUM; n ++) {
        if (gnet_property->props[n].type == PROP_TYPE_STRING) {
			gchar **p = gnet_property->props[n].data.string.value;
			if (*p)
				G_FREE_NULL(*p);
        }
    }

    G_FREE_NULL(gnet_property->props);
    G_FREE_NULL(gnet_property);
}

prop_def_t *gnet_prop_get_def(property_t p)
{
    return prop_get_def(gnet_property, p);
}

/*
 * gnet_prop_add_prop_changed_listener:
 *
 * Add a change listener to a given property. If init is TRUE then
 * the listener is immediately called.
 */
void gnet_prop_add_prop_changed_listener(
    property_t prop, prop_changed_listener_t l, gboolean init)
{
    prop_add_prop_changed_listener(gnet_property, prop, l, init);
}

void gnet_prop_remove_prop_changed_listener(
    property_t prop, prop_changed_listener_t l)
{
    prop_remove_prop_changed_listener(gnet_property, prop, l);
}

void gnet_prop_set_boolean(
    property_t prop, const gboolean *src, gsize offset, gsize length)
{
    prop_set_boolean(gnet_property, prop, src, offset, length);
}

gboolean *gnet_prop_get_boolean(
    property_t prop, gboolean *t, gsize offset, gsize length)
{
    return prop_get_boolean(gnet_property, prop, t, offset, length);
}

void gnet_prop_set_guint32(
    property_t prop, const guint32 *src, gsize offset, gsize length)
{
    prop_set_guint32(gnet_property, prop, src, offset, length);
}

guint32 *gnet_prop_get_guint32(
    property_t prop, guint32 *t, gsize offset, gsize length)
{
    return prop_get_guint32(gnet_property, prop, t, offset, length);
}

void gnet_prop_set_string(property_t prop, const gchar *val)
{
    prop_set_string(gnet_property, prop, val);
}

gchar *gnet_prop_get_string(property_t prop, gchar *t, gsize size)
{
    return prop_get_string(gnet_property, prop, t, size);
}

void gnet_prop_set_storage(property_t p, const guint8 *v, gsize l)
{
    prop_set_storage(gnet_property, p, v, l);
}

guint8 *gnet_prop_get_storage(property_t p, guint8 *t, gsize l)
{
    return prop_get_storage(gnet_property, p, t, l);
}


/*
 * gnet_prop_get_stub:
 *
 * Returns a new stub struct for this property set. Just g_free it
 * when it is no longer needed. All fields are read only!
 */
prop_set_stub_t *gnet_prop_get_stub(void) 
{
    prop_set_stub_t *stub;

    stub          = g_new0(prop_set_stub_t, 1);
    stub->size    = GNET_PROPERTY_NUM;
    stub->offset  = GNET_PROPERTY_MIN;
    stub->get_def = gnet_prop_get_def;

    stub->prop_changed_listener.add = 
        gnet_prop_add_prop_changed_listener;
    stub->prop_changed_listener.remove = 
        gnet_prop_remove_prop_changed_listener;

    stub->boolean.get = gnet_prop_get_boolean;
    stub->boolean.set = gnet_prop_set_boolean;

    stub->guint32.get = gnet_prop_get_guint32;
    stub->guint32.set = gnet_prop_set_guint32;

    stub->string.get = gnet_prop_get_string;
    stub->string.set = gnet_prop_set_string;

    stub->storage.get = gnet_prop_get_storage;
    stub->storage.set = gnet_prop_set_storage;

    return stub;
}

