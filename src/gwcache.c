/*
 * $Id$
 *
 * Copyright (c) 2001-2002, Raphael Manfredi
 *
 * Gnutella Web Cache.
 *
 *----------------------------------------------------------------------
 * This file is part of gtk-gnutella.
 *
 *  gtk-gnutella is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  gtk-gnutella is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with gtk-gnutella; if not, write to the Free Software
 *  Foundation, Inc.:
 *      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *----------------------------------------------------------------------
 */

#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "gwcache.h"
#include "atoms.h"
#include "misc.h"
#include "getline.h"
#include "http.h"
#include "hosts.h"

#include "gnet_property.h"
#include "gnet_property_priv.h"

#include "settings.h"

static gchar gwc_tmp[1024];

/*
 * The web cache URLs are stored in a fixed-sized array: we remember only
 * a handful of URLs, and choose each time a random web cache among the
 * set for interaction.
 *
 * The array `gwc_url' is filled in a round-robin fashion, the last filled
 * position being `gwc_url_slot'.
 *
 * The `gwc_known_url' hash table is actually a search table indexed by an URL
 * to prevent insertion of duplicates in our cache.
 */

#define MAX_GWC_URLS	100

static gchar *gwc_url[MAX_GWC_URLS];		/* Holds string atoms */
static gint gwc_url_slot = -1;
static GHashTable *gwc_known_url = NULL;
static gchar *current_url = NULL;			/* Cache we're currently using */

#define MAX_URL_LINES	50					/* Max lines on a urlfile req */
#define MAX_IP_LINES	50					/* Max lines on a hostfile req */

static gchar *gwc_file = "gwcache";

static void gwc_get_urls(void);

/*
 * gwc_add
 *
 * Add new URL to cache, possibly pushing off an older one if cache is full.
 */
static void gwc_add(gchar *url)
{
	gchar *url_atom;
	gchar *old_url;

	/*
	 * Don't add duplicates in the cache.
	 */

	if (g_hash_table_lookup(gwc_known_url, url))
		return;

	/*
	 * Make sure the entry is well-formed.
	 */

	if (!http_url_parse(url, NULL, NULL, NULL, NULL)) {
		g_warning("ignoring bad web cache URL: %s", url);
		return;
	}

	/*
	 * OK, record new entry.
	 */

	url_atom = atom_str_get(url);
	g_hash_table_insert(gwc_known_url, url_atom, (gpointer) 0x1);

	if (++gwc_url_slot >= MAX_GWC_URLS)
		gwc_url_slot = 0;

	/*
	 * Expire any entry present at the slot we're about to write into.
	 */

	old_url = gwc_url[gwc_url_slot];

	if (old_url != NULL) {
		g_assert(g_hash_table_lookup(gwc_known_url, old_url));
		g_hash_table_remove(gwc_known_url, old_url);
		atom_str_free(old_url);
	}

	gwc_url[gwc_url_slot] = url_atom;
}

/*
 * gwc_pick
 *
 * Pickup a cache randomly from the known set.
 */
static gchar *gwc_pick(void)
{
	gint count = g_hash_table_size(gwc_known_url);
	gint index;

	g_assert(count > 0);
	g_assert(count <= MAX_GWC_URLS || gwc_url_slot < count);

	index = random_value(count - 1);

	return gwc_url[index];
}

/*
 * gwc_store
 *
 * Store known GWC URLs.
 * They are normally saved in ~/.gtk-gnutella/gwcache.
 */
void gwc_store(void)
{
	FILE *out;
	time_t now = time((time_t *) NULL);
	gchar tmp[1024];
	gint i;

	g_snprintf(tmp, sizeof(tmp), "%s/%s.new", config_dir, gwc_file);
	out = fopen(tmp, "w");

	if (!out) {
		g_warning("unable to create %s to persist web cache URLs: %s",
			tmp, g_strerror(errno));
		return;
	}

	fputs("# THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT EDIT\n", out);
	fprintf(out, "#\n# Gnutella web cache URLs saved on %s#\n\n", ctime(&now));

	for (i = 0; i < MAX_GWC_URLS; i++) {
		gchar *url = gwc_url[i];
		if (url == NULL)
			continue;
		fprintf(out, "%s\n", url);
	}

	if (0 == fclose(out)) {
		g_snprintf(gwc_tmp, sizeof(gwc_tmp), "%s/%s", config_dir, gwc_file);
		if (-1 == rename(tmp, gwc_tmp))
			g_warning("could not rename %s as %s: %s",
				tmp, gwc_tmp, g_strerror(errno));
	} else
		g_warning("could not flush %s: %s", tmp, g_strerror(errno));
}

/*
 * gwc_retrieve
 *
 * Retrieve known GWC URLs.
 * They are normally saved in ~/.gtk-gnutella/gwcache.
 */
static void gwc_retrieve(void)
{
	FILE *in;
	gchar tmp[1024];
	gint line;

	g_snprintf(tmp, sizeof(tmp), "%s/%s", config_dir, gwc_file);
	g_snprintf(gwc_tmp, sizeof(gwc_tmp), "%s/%s.orig", config_dir, gwc_file);

	in = fopen(tmp, "r");

	if (in) {
		if (-1 == rename(tmp, gwc_tmp))
			g_warning("could not rename %s as %s: %s",
				tmp, gwc_tmp, g_strerror(errno));
	} else {
		const gchar *error = g_strerror(errno);
		struct stat buf;
		gchar *instead = " instead";

		if (-1 == stat(tmp, &buf))
			instead = "";				/* Regular file was missing */
		else
			g_warning("unable to open \"%s\" to retrieve web cache URLs: %s",
				tmp, error);

		in = fopen(gwc_tmp, "r");
		if (!in)
			return;

		g_warning("retrieving web cache URLs from \"%s\"%s", gwc_tmp, instead);
	}

	/*
	 * Retrieve each line.
	 */

	line = 0;

	while (fgets(tmp, sizeof(tmp) - 1, in)) {	/* Room for trailing NUL */
		line++;

		if (tmp[0] == '#')		/* Skip comments */
			continue;

		if (tmp[0] == '\n')		/* Allow empty lines */
			continue;

		(void) str_chomp(tmp, 0);
		gwc_add(tmp);
	}

	fclose(in);
}

/*
 * gwc_init
 *
 * Initialize web cache.
 */
void gwc_init(void)
{
	gwc_known_url = g_hash_table_new(g_str_hash, g_str_equal);

	/*
	 * The following two URLs are there for bootstrapping purposes only.
	 */

	gwc_add("http://www.gnucleus.net/gcache/gcache.php");
	gwc_add("http://www.zero-g.net/gcache/gcache.php");

	gwc_retrieve();
	gwc_get_urls();
}

/*
 * gwc_close
 *
 * Called when servent shuts down.
 */
void gwc_close(void)
{
	gint i;

	gwc_store();
	g_hash_table_destroy(gwc_known_url);

	for (i = 0; i < MAX_GWC_URLS; i++) {
		gchar *url = gwc_url[i];
		if (url == NULL)
			continue;
		atom_str_free(url);
	}
}

/***
 *** Line-by-line parsing context.
 ***/

struct parse_context {
	getline_t *getline;			/* Used to hold partially read line */
	gpointer handle;			/* Request handle */
	gint maxlines;				/* Maximum number of lines we want to process */
	gint lines;					/* Amount of lines so far */
	gint processed;				/* User callback can count retained lines */
};

typedef void (parse_dispatch_t)(struct parse_context *c, gchar *buf, gint len);
typedef void (parse_eof_t)(struct parse_context *c);

/*
 * parse_context_free
 *
 * Free parsing context.
 */
static void parse_context_free(gpointer obj)
{
	struct parse_context *ctx = (struct parse_context *) obj;

	getline_free(ctx->getline);
	wfree(ctx, sizeof(*ctx));
}

/*
 * parse_context_set
 *
 * Allocate new parsing context for handle and record it.
 *
 * `handle' is the asynchronous HTTP request handle.
 * `maxlines' is the max number of lines we want to parse.
 */
static void parse_context_set(gpointer handle, gint maxlines)
{
	struct parse_context *ctx;

	ctx = walloc(sizeof(*ctx));
	ctx->getline = getline_make();
	ctx->maxlines = maxlines;
	ctx->handle = handle;
	ctx->lines = 0;
	ctx->processed = 0;

	http_async_set_opaque(handle, ctx, parse_context_free);
}


/*
 * parse_dispatch_lines
 *
 * Analyze the data we have received, and give each line to the supplied
 * dispatcher callback `cb', after having chomped it.  On EOF, call `eof'
 * to finalize parsing.
 */
static void parse_dispatch_lines(
	gpointer handle, gchar *buf, gint len, parse_dispatch_t cb, parse_eof_t eof)
{
	struct parse_context *ctx;
	getline_t *getline;
	gchar *p = buf;
	gint remain = len;
	guint parsed;
	gint linelen;
	gchar *linep;

	/*
	 * Retrieve parsing context, stored as an opaque attribute in the
	 * asynchronous HTTP request handle.
	 */
	
	ctx = (struct parse_context *) http_async_get_opaque(handle);

	g_assert(ctx->handle == handle);	/* Make sure it's the right context */

	if (len == 0) {						/* Nothing to parse, got EOF */
		if (eof)
			(*eof)(ctx);
		return;
	}

	/*
	 * Read a line at a time.
	 */

	getline = ctx->getline;

	for (;;) {
		switch (getline_read(getline, p, remain, &parsed)) {
		case READ_OVERFLOW:
			http_async_cancel(handle);
			return;
		case READ_DONE:
			p += parsed;
			remain -= parsed;
			break;
		case READ_MORE:			/* ok, but needs more data */
		default:
			g_assert(parsed == remain);
			return;
		}

		/*
		 * We come here everytime we get a full line.
		 */

		linep = getline_str(getline);
		linelen = str_chomp(linep, getline_length(getline));
		(*cb)(ctx, linep, linelen);

		/*
		 * Make sure we don't process lines ad infinitum.
		 */

		ctx->lines++;
		if (ctx->lines >= ctx->maxlines) {
			gchar *req;
			gchar *url = http_async_info(handle, &req, NULL, NULL, NULL);
			g_warning("got %d+ lines from \"%s %s\", stopping",
				ctx->lines, req, url);
			http_async_cancel(handle);
			return;
		}

		getline_reset(getline);
	}
}

/***
 *** GET ...?urlfile=1
 ***/

/*
 * gwc_url_line
 *
 * Called from parse_dispatch_lines() for each complete line of output.
 */
static void gwc_url_line(struct parse_context *ctx, gchar *buf, gint len)
{
	if (dbg > 4)
		printf("GWC URL line (%d bytes): %s\n", len, buf);

	if (0 == strncmp(buf, "ERROR", 5)) {
		g_warning("GWC cache \"%s\" returned %s",
			http_async_info(ctx->handle, NULL, NULL, NULL, NULL), buf);
		http_async_cancel(ctx->handle);
		return;
	}

	// XXX -- Ignore "chunked" output
	if (len && !(*buf == 'h' || *buf == 'H'))
		return;

	if (len) {
		ctx->processed++;
		gwc_add(buf);		/* Add URL to cache */
	}
}

/*
 * gwc_url_eof
 *
 * Called from parse_dispatch_lines() on EOF.
 */
static void gwc_url_eof(struct parse_context *ctx)
{
	if (dbg > 3)
		printf("GWC URL all done (%d/%d lines processed)\n",
			ctx->processed, ctx->lines);

	if (ctx->processed == 0) {
		current_url = NULL;			/* This webcache is not good */
		gwc_get_urls();				/* Try with another one! */
	}
}

/*
 * gwc_url_data_ind
 *
 * Populate callback: more data available.
 */
static void gwc_url_data_ind(gpointer handle, gchar *data, gint len)
{
	parse_dispatch_lines(handle, data, len, gwc_url_line, gwc_url_eof);
}

/*
 * gwc_url_error_ind
 *
 * HTTP request is being stopped.
 */
static void gwc_url_error_ind(gpointer handle, http_errtype_t type, gpointer v)
{
	http_async_log_error(handle, type, v);

	current_url = NULL;				/* This webcache is not good */
	gwc_get_urls();					/* Try with another one! */
}

/*
 * gwc_get_urls
 *
 * Retrieve more web caches, asynchronously.
 *
 * We'll try again and again, until we reach a good cache that answers
 * with at least one request.
 */
static void gwc_get_urls(void)
{
	gpointer handle;

	if (current_url == NULL)
		current_url = gwc_pick();

	g_snprintf(gwc_tmp, sizeof(gwc_tmp),
		"%s?urlfile=1"
		"&client=GTKG"
		"&version=%u.%u%s",
		current_url, GTA_VERSION, GTA_SUBVERSION, GTA_REVCHAR);

	if (dbg > 3)
		printf("GWC URL request: %s\n", gwc_tmp);

	/*
	 * Launch the asynchronous request and attach parsing information.
	 */

	handle = http_async_get(gwc_tmp,
		NULL, gwc_url_data_ind, gwc_url_error_ind);

	parse_context_set(handle, MAX_URL_LINES);
}

/***
 *** GET ...?hostfile=1
 ***/

static gboolean hostfile_running = FALSE;

/*
 * gwc_host_line
 *
 * Called from parse_dispatch_lines() for each complete line of output.
 */
static void gwc_host_line(struct parse_context *ctx, gchar *buf, gint len)
{
	if (dbg > 4)
		printf("GWC host line (%d bytes): %s\n", len, buf);

	if (0 == strncmp(buf, "ERROR", 5)) {
		g_warning("GWC cache \"%s\" returned %s",
			http_async_info(ctx->handle, NULL, NULL, NULL, NULL), buf);
		http_async_cancel(ctx->handle);
		return;
	}

	if (len) {
		guint32 ip;
		guint16 port;

		if (gchar_to_ip_port(buf, &ip, &port)) {
			ctx->processed++;
			host_add(ip, port, FALSE);
		}
	}
}

/*
 * gwc_host_eof
 *
 * Called from parse_dispatch_lines() on EOF.
 */
static void gwc_host_eof(struct parse_context *ctx)
{
	if (dbg > 3)
		printf("GWC host all done (%d/%d lines processed)\n",
			ctx->processed, ctx->lines);

	if (ctx->processed == 0)
		current_url = NULL;			/* This webcache is not good */

	hostfile_running = FALSE;
}

/*
 * gwc_host_data_ind
 *
 * Populate callback: more data available.
 */
static void gwc_host_data_ind(gpointer handle, gchar *data, gint len)
{
	parse_dispatch_lines(handle, data, len, gwc_host_line, gwc_host_eof);
}

/*
 * gwc_host_error_ind
 *
 * HTTP request is being stopped.
 */
static void gwc_host_error_ind(gpointer handle, http_errtype_t type, gpointer v)
{
	http_async_log_error(handle, type, v);
	hostfile_running = FALSE;
}

/*
 * gwc_get_hosts
 *
 * Retrieve more hosts from web cache, asynchronously.
 */
void gwc_get_hosts(void)
{
	gpointer handle;

	/*
	 * Make sure we don't probe more than one webcache at a time.
	 */

	if (hostfile_running)
		return;

	if (current_url == NULL)
		current_url = gwc_pick();

	g_snprintf(gwc_tmp, sizeof(gwc_tmp),
		"%s?hostfile=1"
		"&client=GTKG"
		"&version=%u.%u%s",
		current_url, GTA_VERSION, GTA_SUBVERSION, GTA_REVCHAR);

	if (dbg > 3)
		printf("GWC host request: %s\n", gwc_tmp);

	/*
	 * Launch the asynchronous request and attach parsing information.
	 */

	handle = http_async_get(gwc_tmp,
		NULL, gwc_host_data_ind, gwc_host_error_ind);

	parse_context_set(handle, MAX_IP_LINES);
	hostfile_running = TRUE;
}

