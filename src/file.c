/*
 * $Id$
 *
 * Copyright (c) 2002, Raphael Manfredi
 *
 * Miscellaneous common file routines.
 *
 *----------------------------------------------------------------------
 * This file is part of gtk-gnutella.
 *
 *  gtk-gnutella is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  gtk-gnutella is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with gtk-gnutella; if not, write to the Free Software
 *  Foundation, Inc.:
 *      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *----------------------------------------------------------------------
 */

#include "common.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

static gchar *orig_ext = ".orig";
static gchar *new_ext = ".new";
static gchar *instead_str = " instead";
static gchar *empty_str = "";

static gchar file_tmp[2048];

/*
 * file_config_open_read
 *
 * Open configuration file, renaming it as ".orig".  If configuration file
 * cannot be found, try opening the ".orig" variant if already present.
 * If not found, try with successive alternatives, if supplied.
 *
 * NB: the supplied `fv' argument is a vector of `fvcnt' elements.
 *
 * Returns opened FILE, or NULL if we were unable to open any.
 */
FILE *file_config_open_read(gchar *what, file_path_t *fv, gint fvcnt)
{
	FILE *in;
	gchar tmp[2048];
	gchar *error;
	struct stat buf;
	gchar *instead = empty_str;

	g_assert(fv != NULL);
	g_assert(fvcnt >= 1);

	g_snprintf(tmp, sizeof(tmp), "%s/%s", fv->dir, fv->name);
	g_snprintf(file_tmp, sizeof(file_tmp), "%s%s", tmp, orig_ext);

	in = fopen(tmp, "r");

	if (in) {
		if (-1 == rename(tmp, file_tmp))
			g_warning("could not rename %s as %s: %s",
				tmp, file_tmp, g_strerror(errno));
		return in;
	}

	error = g_strerror(errno);

	if (-1 != stat(tmp, &buf)) {
		instead = instead_str;			/* Regular file was present */
		g_warning("unable to open \"%s\" to retrieve %s: %s", tmp, what, error);
	}

	/*
	 * Maybe we crashed after having retrieved the file in a previous run
	 * but before being able to write it again correctly?  Try to open the
	 * ".orig" file instead.
	 */

	in = fopen(file_tmp, "r");			/* The ".orig", in case of a crash */

	/*
	 * Try with alternatives, if supplied.
	 */

	if (in == NULL && fvcnt > 1) {
		file_path_t *xfv;
		gint xfvcnt;

		instead = instead_str;

		for (xfv = fv + 1, xfvcnt = fvcnt - 1; xfvcnt; xfv++, xfvcnt--) {
			g_snprintf(file_tmp, sizeof(file_tmp),
				"%s/%s", xfv->dir, xfv->name);
			
			in = fopen(file_tmp, "r");
			if (in)
				break;
		}
	}

	if (in)
		g_warning("retrieving %s from \"%s\"%s", what, file_tmp, instead);
	else if (instead == instead_str)
		g_warning("unable to retrieve %s, tried %d alternate location%s",
			what, fvcnt, fvcnt == 1 ? "" : "s");

	return in;
}

/*
 * file_config_open_write
 *
 * Open configuration file for writing.  We don't clobber the existing file
 * yet and open a ".new" instead.  Renaming will occur afterwards, when
 * file_config_close() is called.
 *
 * Returns opened FILE if success, NULL on error.
 */
FILE *file_config_open_write(gchar *what, file_path_t *fv)
{
	FILE *out;

	g_snprintf(file_tmp, sizeof(file_tmp),
		"%s/%s%s", fv->dir, fv->name, new_ext);

	out = fopen(file_tmp, "w");

	if (out == NULL)
		g_warning("unable to create \"%s\" to persist %s: %s",
			file_tmp, what, g_strerror(errno));

	return out;
}

/*
 * file_config_close
 *
 * Close configuration file opened for writing, and rename it.
 * Returns TRUE on success.
 */
gboolean file_config_close(FILE *out, file_path_t *fv)
{
	gchar tmp[2048];

	g_snprintf(file_tmp, sizeof(file_tmp),
		"%s/%s%s", fv->dir, fv->name, new_ext);

	if (0 != fclose(out)) {
		g_warning("could not flush \"%s\": %s", file_tmp, g_strerror(errno));
		return FALSE;
	}

	g_snprintf(tmp, sizeof(tmp), "%s/%s", fv->dir, fv->name);
		
	if (-1 == rename(file_tmp, tmp)) {
		g_warning("could not rename \"%s\" as \"%s\": %s",
			file_tmp, tmp, g_strerror(errno));
		return FALSE;
	}

	return TRUE;
}

/*
 * file_config_preamble
 *
 * Emit the configuration preamble.
 */
void file_config_preamble(FILE *out, gchar *what)
{
	time_t now = time((time_t *) NULL);

	g_assert(out);

	fputs("# THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT EDIT\n", out);
	fprintf(out, "#\n# %s saved on %s#\n\n", what, ctime(&now));
}

