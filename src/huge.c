/*
 * Copyright (c) 2002, Ch. Tronche & Raphael Manfredi
 *
 * HUGE support (Hash/URN Gnutella Extension).
 *
 * Started by Ch. Tronche (http://tronche.com/) 28/04/2002
 *
 *----------------------------------------------------------------------
 * This file is part of gtk-gnutella.
 *
 *  gtk-gnutella is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  gtk-gnutella is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with gtk-gnutella; if not, write to the Free Software
 *  Foundation, Inc.:
 *      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *----------------------------------------------------------------------
 */

#include <errno.h>
#include <fcntl.h>
#include <glib.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include "appconfig.h"
#include "base32.h"
#include "sha1.h"
#include "huge.h"
#include "share.h"

/***
 *** Server side: computation of SHA1 hash digests and replies.
 *** SHA1 is defined in RFC 3174.
 ***/

/*
 * There's an in-core cache (the GHashTable sha1_cache), and a
 * persistent copy (normally in ~/.gtk-gnutella/sha1_cache). The
 * in-core cache is filled with the persistent one at launch. When the
 * "shared_file" (the records describing the shared files, see
 * share.h) are created, a call is made to sha1_set_digest to fill the
 * SHA1 digest part of the shared_file. If the digest isn't found in
 * the in-core cache, it's computed, stored in the in-core cache and
 * appended at the end of the persistent cache. If the digest is found
 * in the cache, a check is made based on the file size and last
 * modification time. If they're identical to the ones in the cache,
 * the digest is considered to be accurate, and is used. If the file
 * size or last modification time don't match, the digest is computed
 * again and stored in the in-core cache, but it isn't stored in the
 * persistent one. Instead, the cache is marked as dirty, and will be
 * entirely overwritten by dump_cache, called when everything has been
 * computed.
 */

struct sha1_cache_entry {
    gchar *file_name;                     /* Full path name                 */
    off_t  size;                          /* File size                      */
    time_t mtime;                         /* Last modification time         */
    guchar digest[SHA1_BASE32_SIZE];      /* SHA1 digest as an ASCII string */
    gboolean shared;                      /* There's a known entry for this
                                           * file in the share library
                                           */
};

static GHashTable *sha1_cache = NULL;

/* 
 * cache_dirty means that in-core cache is different from the one on disk when
 * TRUE.
 */
static gboolean cache_dirty = FALSE;

/**
 ** Elementary operations on SHA1 values
 **/

/*
 * copy_sha1
 *
 * Copy the ASCII representation of a SHA1 digest from source to dest. 
 */
static void copy_sha1(char *dest, const char *source)
{
	memcpy(dest, source, SHA1_BASE32_SIZE);
}

/**
 ** Handling of persistent buffer
 **/

/* In-memory cache */

/* 
 * update_volatile_cache
 *
 * Takes an in-memory cached entry, and update its content.
 */
static void update_volatile_cache(
	struct sha1_cache_entry *sha1_cached_entry,
	off_t size,
	time_t mtime, 
	const char *sha1_digest_ascii)
{
	sha1_cached_entry->size = size;
	sha1_cached_entry->mtime = mtime;
	copy_sha1(sha1_cached_entry->digest, sha1_digest_ascii);
	sha1_cached_entry->shared = TRUE;
}

/* add_volatile_cache_entry
 * 
 * Add a new entry to the in-memory cache.
 */
static void add_volatile_cache_entry(
	const char *file_name, 
	off_t size,
	time_t mtime,
	const char *sha1_digest_ascii, 
	gboolean known_to_be_shared)
{
	struct sha1_cache_entry *new_entry = g_new(struct sha1_cache_entry, 1);
	new_entry->file_name = g_strdup(file_name); /* Sorry about that ! */
	new_entry->size = size;
	new_entry->mtime = mtime;
	copy_sha1(new_entry->digest, sha1_digest_ascii);
	new_entry->shared = known_to_be_shared;
	g_hash_table_insert(sha1_cache, new_entry->file_name, new_entry);
}

/* Disk cache */

static const char sha1_persistent_cache_file_header[] = 
"#\n"
"# gtk-gnutella SHA1 cache file.\n"
"# This file is automatically generated.\n"
"# Format is: SHA1 digest<TAB>file_size<TAB>file_mtime<TAB>file_name\n"
"# Comment lines start with a sharp (#)\n"
"#\n"
"\n";

static char *persistent_cache_file_name = NULL;

/* 
 * add_persistent_cache_entry
 * 
 * Add an entry to the persistent cache.
 */
static void add_persistent_cache_entry(
	const char *file_name,
	off_t size,
	time_t mtime,
	const char *sha1_digest_ascii)
{
	FILE *persistent_cache;

	if (!persistent_cache_file_name)
		return;

	persistent_cache = fopen(persistent_cache_file_name, "a");

	if (!persistent_cache) {
		g_warning("Unable to open persistent SHA1 cache file: %s",
			strerror(errno));
		return;
	}

	/*
	 * If we're adding the very first entry (file empty), then emit header.
	 */

	if (0 == ftell(persistent_cache))
		fprintf(persistent_cache, "%s", sha1_persistent_cache_file_header);

	fwrite(sha1_digest_ascii, SHA1_BASE32_SIZE, 1, persistent_cache);
	fprintf(persistent_cache, "\t%lu\t%ld\t%s\n",
		(gulong) size, mtime, file_name);
	fclose(persistent_cache);
}

/*
 * dump_cache_one_entry
 * 
 * Dump one (in-memory) cache into the persistent cache. This is a callback
 * called by dump_cache to dump the whole in-memory cache onto disk.
 */
static void dump_cache_one_entry(
	const char *file_name,
	struct sha1_cache_entry *e,
	FILE *persistent_cache)
{
	if (!e->shared)
		return;

	fwrite(e->digest, SHA1_BASE32_SIZE, 1, persistent_cache);
	fprintf(persistent_cache,
		"\t%lu\t%ld\t%s\n", (gulong) e->size, e->mtime, e->file_name);
}

/*
 * dump_cache
 *
 * Dump the whole in-memory cache onto disk.
 */
static void dump_cache(void)
{
	FILE *persistent_cache;

	persistent_cache = fopen(persistent_cache_file_name, "w");

	if (!persistent_cache) {
		g_warning("Dump cache: unable to open persistent SHA1 cache file: %s",
			strerror(errno));
		return;
	}

	fprintf(persistent_cache, "%s", sha1_persistent_cache_file_header);
	g_hash_table_foreach(sha1_cache,
		(GHFunc)dump_cache_one_entry, persistent_cache);
	fclose(persistent_cache);
}

/*
 * parse_and_append_cache_entry
 * 
 * This function is used to read the disk cache into memory. It must be passed
 * one line from the cache (ending with '\n'). It performs all the
 * syntactic processing to extract the fields from the line and calls
 * add_volatile_cache_entry to append the record to the in-memory cache.
 */
static void parse_and_append_cache_entry(char *line)
{
	const char *sha1_digest_ascii;
	char *sha1_digest_ascii_end;
	const char *file_name;
	char *file_name_end;
	char *p, *end; /* pointers to scan the line */
	off_t size;
	time_t mtime;

	/* Skip comments and blank lines */
	if (*line == '#' || *line == '\n') return;

	sha1_digest_ascii = line; /* SHA1 digest is the first field. */

	/* Scan until file size */

	p = line;
	while(*p != '\t' && *p != '\n') p++;
	if (*p != '\t') {
		g_warning("Malformed line in SHA1 cache file %s[SHA1]: %s",
			persistent_cache_file_name, line);
		return;
	}

	sha1_digest_ascii_end = p++;  /* Set the end of the SHA1 digest string */

	/* p is now supposed to point to the beginning of the file size */

	size = strtoul(p, &end, 10);
	if (end == p || *end != '\t') {
		g_warning("Malformed line in SHA1 cache file %s[size]: %s",
			persistent_cache_file_name, line);
		return;
	}

	p = end + 1;

	/*
	 * p is now supposed to point to the beginning of the file last
	 * modification time.
	 */

	mtime = strtoul(p, &end, 10);
	if (end == p || *end != '\t') {
		g_warning("Malformed line in SHA1 cache file %s[mtime]: %s", 
			persistent_cache_file_name, line);
		return;
	}

	p = end + 1;

	/* p is now supposed to point to the file name */

	file_name = p;
	file_name_end = strchr(file_name, '\n');

	if (!file_name_end) {
		g_warning("Malformed line in SHA1 cache file %s[file_name]: %s",
			persistent_cache_file_name, line);
		return;
	}

	/* Set string end markers */
	*sha1_digest_ascii_end = '\0';
	*file_name_end = '\0';

	add_volatile_cache_entry(file_name, size, mtime, sha1_digest_ascii, FALSE);
}

/*
 * sha1_read_cache
 * 
 * Read the whole persistent cache into memory.
 */
static void sha1_read_cache()
{
	char buffer[4096];
	FILE *persistent_cache_file;
	char *fgets_return;

	if (!config_dir) {
		g_warning("No config dir");
		return;
	}

	g_snprintf(buffer, sizeof(buffer), "%s/sha1_cache", config_dir);
	persistent_cache_file_name = g_strdup(buffer);
	  
	persistent_cache_file = fopen(persistent_cache_file_name, "r");
	if (!persistent_cache_file) {
		g_warning("Unable to open SHA1 persistent cache %s: %s", 
			persistent_cache_file_name, strerror(errno));
		cache_dirty = TRUE;
		return;
	}
	  
	for(;;) {
		fgets_return = fgets(buffer, sizeof(buffer), persistent_cache_file);
		if (!fgets_return)
			break;
		parse_and_append_cache_entry(buffer);
	}

	fclose(persistent_cache_file);
}

/**
 ** Asynchronous computation of hash value
 **/

/*
 * Computation is performed through the sha1_timer timer, called by
 * the GTK main loop. It has some "credit" to perform its operations
 * (either computing the hash for a maximum of HASH_BLOCK_SIZE bytes, or
 * some special operations like opening the next file). The actual time
 * taken by the task is measured. If it's too long, credit is
 * decreased by 1/4th. If it's within the limit, the credit is doubled
 * for next iteration. Thus the credit slowly oscillates between max
 * and 2 * max. Here max = 0.1 sec. On my pentium III 866 MHz, it
 * allows the computation to be performed on a slice of 1000 to 2000
 * Kbytes of data, that is, the computation of a hash for a file of 5
 * Mbytes ranges from 2.5 to 5 seconds. 
 */

#define MAX_HALF_LIFE 	50000		/* in microseconds, MUST be << 1 sec */
#define HASH_BLOCK_SIZE	4096		/* size of a hash unit credit */
#define TIMEOUT_PERIOD	(1000 - (MAX_HALF_LIFE/1000))

static gint sha1_timeout_tag = 0;
static int credit = 1;

/* This is a file waiting either for the digest to be computer, or
 * when computed to be retrofit into the share record. 
 */

struct file_sha1 {
	char *file_name;
	guint32 file_index;

	/*
	 * This is used only if this record is
	 * in the waiting_for_library_build_complete list.
	 */

	gchar sha1_digest[SHA1_BASE32_SIZE];
	struct file_sha1 *next;
};

/* Two useful lists */

/*
 * When a hash is requested for a file and is unknown, it is first stored onto
 * this stack, waiting to be processed.
 */

static struct file_sha1 *waiting_for_sha1_computation = NULL;

/* 
 * When the hash for a file has been computed but cannot be set into the struct
 * shared_file because the function shared_file returned SHARE_REBUILDING (for
 * example), the corresponding struct file_hash is stored into this stack, until
 * such time it's possible to get struct shared_file from index with
 * shared_file. 
 */

static struct file_sha1 *waiting_for_library_build_complete = NULL;

/* 
 * push
 * 
 * Push a record onto a stack (either waiting_for_sha1_computation or
 * waiting_for_library_build_complete).
 */

static void push(struct file_sha1 **stack,struct file_sha1 *record)
{
	record->next = *stack;
	*stack = record;
}

/* The context of the SHA1 computation being performed */

static SHA1Context context;
static struct file_sha1 *current_file = NULL;
static int current_fd = -1;
static time_t current_start;		/* Debugging, show computation rate */

/* 
 * adjust_credit
 * 
 * Adjust the credit. start is the time at which the timeout callback
 * started, end the time when it ended.
 */
static void adjust_credit(
	const struct timeval *start, 
	const struct timeval *end)
{
	int delta_seconds = end->tv_sec - start->tv_sec;
	int delta_useconds =
		end->tv_usec - start->tv_usec + delta_seconds * 1000 * 1000;

	/*
	 * Double credit for next iteration if we are under the half life,
	 * but remove one fourth of the credit if we are above twice that
	 * elapsed time.  That's coarse grain adjustments.
	 *
	 * Within the [half-life, 2* half-life] interval, we shoot for
	 * the middle of the interval, by making linear adjustments.
	 */

	if (delta_useconds < MAX_HALF_LIFE)
		credit += credit;
	else if (delta_useconds > MAX_HALF_LIFE * 2)
		credit -= credit >> 2;
	else
		credit = (gint) (credit *
			(gfloat) (MAX_HALF_LIFE + MAX_HALF_LIFE/2) / delta_useconds);

	/* Be sure to be able to execute at least one step */

	if (credit <= 0)
		credit = 1;

	if (dbg > 4) {
		printf("adjust_credit: elapsed: %d usec, new credit = %d\n",
			delta_useconds, credit);
		fflush(stdout);
	}
}

/* 
 * put_sha1_back_into_share_library
 * 
 * When SHA1 is computed, and we know what struct share it's related
 * to, we call this function to update set the share SHA1 value.
 */
static void put_sha1_back_into_share_library(
	struct shared_file *sf,
	guint32 file_index,
	const char *file_name,
	const char *digest)
{
	char full_file_name[4096];
	struct sha1_cache_entry *cached_sha1;

	if (!sf) {
		fprintf(stderr, "Got SHA1 for unknown file %s ???\n", file_name);
		return;
	}

	g_snprintf(full_file_name, sizeof(full_file_name),
		"%s/%s", sf->file_directory, sf->file_name);

	if (0 != strcmp(full_file_name, file_name)) {

		/*
		 * File name changed since last time
		 * (that is, "rescan dir" was called)
		 */

		if (dbg > 1)
			printf("SHA1: name of file #%d changed from %s to %s (reload ?): "
				"discarding\n", file_index, file_name, full_file_name);

		return;
	}

	set_sha1(sf, digest);

	/* Update cache */

	cached_sha1 = (struct sha1_cache_entry *)
		g_hash_table_lookup(sha1_cache, (gconstpointer)full_file_name);

	if (cached_sha1) {
		update_volatile_cache(cached_sha1, sf->file_size, sf->mtime, digest);
		cache_dirty = TRUE;
	} else {
		add_volatile_cache_entry(full_file_name,
			sf->file_size, sf->mtime, digest, TRUE);
		add_persistent_cache_entry(full_file_name,
			sf->file_size, sf->mtime, digest);
	}
}

/* 
 * try_to_put_sha1_back_into_share_library
 *
 * We have some SHA1 we couldn't put the values into the share library
 * because it wasn't available. We try again. This function is called from the
 * sha1_timer. 
 */
static void try_to_put_sha1_back_into_share_library()
{
	struct shared_file *sf;

	if (!waiting_for_library_build_complete)
		return;

	/*
	 * Check to see if we'll be able to get the share from the indexes.
	 */

	sf = shared_file(1);
	if (sf == SHARE_REBUILDING)
		return;						/* Nope. Try later. */

	while (waiting_for_library_build_complete) {
		struct file_sha1 *f = waiting_for_library_build_complete;
		waiting_for_library_build_complete = f->next;
		put_sha1_back_into_share_library(sf,
			f->file_index, f->file_name, f->sha1_digest);
		g_free(f->file_name);
		g_free(f);
	}
}

/*
 * free_cell
 *
 * Free a working cell.
 */
static void free_cell(struct file_sha1 *cell)
{
	g_free(cell->file_name);
	g_free(cell);
}

/* 
 * close_current_file
 * 
 * Close the file whose hash we're computing (after calculation completed) and
 * free the associated structure.
 */
static void close_current_file(void)
{
	if (current_file) {
		free_cell(current_file);
		current_file = NULL;
	}
	if (current_fd != -1) {
		if (dbg > 1) {
			struct stat buf;
			time_t delta = time((time_t *) NULL) - current_start;

			if (delta && -1 != fstat(current_fd, &buf))
				printf("SHA1 computation rate: %ld bytes/sec\n",
					buf.st_size / delta);
		}
		close(current_fd);
		current_fd = -1;
	}
}

/* 
 * get_next_file_from_list
 * 
 * Get the next file waiting for its hash to be computed from the queue
 * (actually a stack).
 * 
 * Returns this file.
 */
static struct file_sha1 *get_next_file_from_list(void)
{
	struct file_sha1 *l;

	/*
	 * XXX HACK ALERT
	 *
	 * We need to be careful here, because each time the library is rescanned,
	 * we add file to the list of SHA1 to recompute if we don't have them
	 * yet.  This means that when we rescan the library during a computation,
	 * we'll add duplicates to our working queue.
	 *
	 * Fortunately, we can probe our in-core cache to see if what we have
	 * is already up-to-date.
	 *
	 * XXX It would be best to maintain a hash table of all the filenames
	 * XXX in our workqueue and not enqueue the work in the first place.
	 * XXX		--RAM, 21/05/2002
	 */

	for (;;) {
		struct sha1_cache_entry *cached;

		l = waiting_for_sha1_computation;

		if (!l)
			return NULL;

		waiting_for_sha1_computation = waiting_for_sha1_computation->next;

		cached = (struct sha1_cache_entry *)
			g_hash_table_lookup(sha1_cache, (gconstpointer) l->file_name);

		if (cached) {
			struct stat buf;

			if (-1 == stat(l->file_name, &buf)) {
				g_warning("ignoring SHA1 recomputation request for \"%s\": %s",
					l->file_name, g_strerror(errno));
				continue;
			}

			if (cached->size == buf.st_size && cached->mtime == buf.st_mtime) {
				if (dbg > 1)
					printf("ignoring duplicate SHA1 work for \"%s\"\n",
						l->file_name);
				continue;
			}
		}

		return l;
	}
}

/* 
 * open_next_file
 * 
 * Open the next file waiting for its hash to be computed.
 * 
 * Returns TRUE if open succeeded, FALSE otherwise.
 */
static gboolean open_next_file(void)
{
	current_file = get_next_file_from_list();

	if (!current_file)
		return FALSE;			/* No more file to process */

	if (dbg > 1) {
		printf("Computing SHA1 digest for %s\n", current_file->file_name);
		current_start = time((time_t *) NULL);
	}

	current_fd = open(current_file->file_name, O_RDONLY);

	if (current_fd < 0) {
		g_warning("Unable to open %s for computing SHA1 hash: %s\n",
			current_file->file_name, strerror(errno));
		close_current_file();
		return FALSE;
	}

	SHA1Reset(&context);

	return TRUE;
}

/*
 * got_sha1_result
 * 
 * Callback to be called when a computation has completed.
 */
static void got_sha1_result(
	guint32 file_index,
	const char *file_name,
	char *digest)
{
	char digest_b32[SHA1_BASE32_SIZE];
	struct shared_file *sf;

	base32_encode_into(digest, SHA1HashSize, digest_b32, sizeof(digest_b32));

	sf = shared_file(file_index);
	if (sf == SHARE_REBUILDING) {
		/*
		 * We can't retrofit SHA1 hash into shared_file now, because we can't
		 * get the shared_file yet.
		 */

		copy_sha1(current_file->sha1_digest, digest_b32);

		/* Re-use the record to save some time and heap fragmentation */

		push(&waiting_for_library_build_complete, current_file);
		current_file = NULL;
	} else
		put_sha1_back_into_share_library(sf, file_index, file_name, digest_b32);
}

/*
 * sha1_timer_one_step
 * 
 * The timer calls repeatedly this function, consuming one unit of
 * credit every call.
 */
static void sha1_timer_one_step(void)
{
	char buffer[HASH_BLOCK_SIZE];
	ssize_t r;
	int res;

	if (!current_file && !open_next_file())
		return;

	r = read(current_fd, buffer, HASH_BLOCK_SIZE);
	if (r < 0) {
		g_warning("Error while reading %s for computing SHA1 hash: %s\n",
			current_file->file_name, strerror(errno));
		close_current_file();
		return;
	}

	if (r == 0) {						/* EOF */
		guint8 digest[SHA1HashSize];
		SHA1Result(&context, digest);
		got_sha1_result(current_file->file_index,
			current_file->file_name, digest);
		close_current_file();
		return;
	}

	res = SHA1Input(&context, buffer, r);
	if (res != shaSuccess) {
		g_warning("SHA1 error while computing hash for %s\n",
			current_file->file_name);
		close_current_file();
	}
}

/* 
 * sha1_timer
 * 
 * The timer doing all the work. This is a glib timeout callback, so it must
 * return TRUE to be called again, or FALSE to never be called again.
 */
static gboolean sha1_timer(gpointer p)
{
	int i;
	struct timeval start, end;
	gboolean call_timer_again;

	if (dbg > 4)
		printf("sha1_timer: credit = %d\n", credit);

	gettimeofday(&start, NULL);
	for(i = credit; i; i--) {
		if (!current_file && !waiting_for_sha1_computation)
			goto no_adjust;		/* We don't use all our credit, don't adjust */
		sha1_timer_one_step();
	}
	gettimeofday(&end, NULL);
	adjust_credit(&start, &end);

no_adjust:
	if (waiting_for_library_build_complete) 
		try_to_put_sha1_back_into_share_library();

	call_timer_again = current_file
		|| waiting_for_sha1_computation
		|| waiting_for_library_build_complete;

	if (!call_timer_again) {
		if (cache_dirty)
			dump_cache();
		sha1_timeout_tag = 0;
	}

	return call_timer_again;
}
  
/**
 ** External interface
 **/

/* This is the external interface. During the share library building,
 * computation of SHA1 values for shared_file is repeatedly requested
 * through sha1_set_digest. If the value is found in the cache (and
 * the cache is up to date), it's set immediately. Otherwise, the file
 * is put in a queue for it's SHA1 digest to be computed.
 */

/* 
 * queue_shared_file_for_sha1_computation
 * 
 * Put the file with a given file_index and file_name on the stack of the things
 * to do. Activate the timer if this wasn't done already.
 */
static void queue_shared_file_for_sha1_computation(
	guint32 file_index,
	const char *file_name)
{
	struct file_sha1 *new_cell = g_malloc(sizeof(struct file_sha1));

	new_cell->file_name = g_strdup(file_name);
	new_cell->file_index = file_index;
	push(&waiting_for_sha1_computation, new_cell);

	if (!sha1_timeout_tag) {
		g_assert(TIMEOUT_PERIOD > 0);
		sha1_timeout_tag = g_timeout_add(TIMEOUT_PERIOD, sha1_timer, NULL);
		g_assert(sha1_timeout_tag);
	}
}

/* 
 * cached_entry_up_to_date
 * 
 * Check to see if an (in-memory) entry cache is up to date.
 * Returns true (in the C sense) if it is, or false otherwise.
 */
static gboolean cached_entry_up_to_date(
	struct sha1_cache_entry *cache_entry,
	struct shared_file *sf)
{
	return cache_entry->size == sf->file_size
		&& cache_entry->mtime == sf->mtime;
}

/* 
 * requested_sha1
 * 
 * External interface to call for getting the hash for a shared_file.
 */
void request_sha1(struct shared_file *sf)
{
	char full_file_name[4096];
	struct sha1_cache_entry *cached_sha1;

	g_snprintf(full_file_name, sizeof(full_file_name),
		"%s/%s", sf->file_directory, sf->file_name);

	cached_sha1 = (struct sha1_cache_entry *)
		g_hash_table_lookup(sha1_cache, (gconstpointer)full_file_name);

	if (cached_sha1 && cached_entry_up_to_date(cached_sha1, sf)) {
		set_sha1(sf, cached_sha1->digest);
		cached_sha1->shared = TRUE;
		return;
	}

	queue_shared_file_for_sha1_computation(sf->file_index, full_file_name);
}

/**
 ** Init
 **/

/*
 * huge_init
 *
 * Initialize SHA1 module
 */
void huge_init(void)
{
	sha1_cache = g_hash_table_new(g_str_hash, g_str_equal);
	sha1_read_cache();
}

/*
 * huge_close
 *
 * Called when servent is shutdown.
 */
void huge_close(void)
{
	if (sha1_timeout_tag)
		g_source_remove(sha1_timeout_tag);

	// XXX -- to be filled up
}

/* 
 * Emacs stuff:
 * Local Variables: ***
 * c-indentation-style: "bsd" ***
 * fill-column: 80 ***
 * tab-width: 4 ***
 * indent-tabs-mode: nil ***
 * End: ***
 */
