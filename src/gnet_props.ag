autogen definitions 'props.tpl';

/*
 * $Id$
 */

uses = "sockets.h";
uses = "gnet.h";
uses = "bsched.h";

property_set = "gnet_property";
func_prefix  = "gnet_prop";
offset = 0;

prop = {
    name = "reading_hostfile";
    desc = "Indicates wether the hostcache file is being read";
    type = boolean;
    save = FALSE;
    data = {  
        default = FALSE;
    };
};


prop = {
    name = "ancient_version";
    desc = "Indicates that gtk-gnutella finds the version you run "
           "very very old";
    type = boolean;
    save = FALSE;
    data = { 
        default = FALSE;
    };
};
  
prop = {
    name = "new_version_str";
    desc = "Gtk-gnutella found a newer version on the gNet and gives "
           "information about it here";
    type = string;
    save = FALSE;
    data = { 
        default = NULL;
    };
};

prop = {
    name = "up_connections";
    desc = "Try to keep at least this number of connections to other " 
           "servents.  This should be smaller than the maximum amount "
		   "of connections to allow incoming connections.";
    type = guint32;
    data = {
        default = 3;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "max_connections";
    desc = "Don't allow more that this number of connections to other "
           "servents.  As a rule of thumb you should resevere 1kb/s "
	   "bandwidth per connection. Never use up all your bandwidth, "
	   "leave a little space for TCP/IP overhead.";
    type = guint32;
    data = {
        default = 4;
        min     = 0;
        max     = 100;
    };
};
prop = {
    name ="max_downloads";
    cfgvar = "max_simultaneous_downloads";
    desc = "Don't start more than this number of parallel downloads.  "
		   "Others will remain in the queue waiting for a download slot.";
    type = guint32;
    data = {
        default = 10;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "max_host_downloads";
    cfgvar = "max_simultaneous_host_downloads";
    desc = "Don't make more connections than given here to a single host "
           "to download a file.  Be nice to others, and leave that at "
		   "the default value (1).";
    type = guint32;
    data = {
        default = 1;
        min     = 1;
        max     = 10;
    };
};

prop = {
    name = "max_uploads";
    cfgvar = "max_simultaneous_uploads";
    desc = "Don't allow more than this number of uploads in total";
    type = guint32;
    data = {
        default = 4;
        value   = max_uploads;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "max_uploads_ip";
    desc = "Don't upload more than this number of files in parallel to a "
           "single host";
    type = guint32;
    data = {
        default = 1;
        min     = 1;
        max     = 100; 
    }; 
};

prop = {
    name = "local_ip";
    desc = "Local IP address last determined";
    save = TRUE;
    type = ip;
    data = {
        default = 0x00000000;
    };
};

prop = {
    name = "listen_port";
    desc = "Local port gtk-gnutella is listening on";
    type = guint32;
    data = {
        default = 6346;
        min     = 0x0000;
        max     = 0xFFFF;
    };
};

prop = {
    name = "forced_local_ip";
    desc = "Use this IP address as source address if 'force local ip' "
           "is activated";
    type = ip;
    data = {
        default = 0x00000000;
    }; 
};

prop = {
    name = "connection_speed";
    desc = "The connection bandwidth reported to other hosts";
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 2000;
    };
};

prop = {
    name = "query_response_max_items";
    cfgvar = "limit_search_results";
    desc = "Return at most this number of results to a query, using as many "
		   "query hit packets as necessary.  To avoid network flooding, keep "
		   "this to a reasonable value.";
    type = guint32;
    data = { 
        default = 50;
        value   = search_max_items;
        min     = 1;
        max     = 500;
    };
};

prop = {
    name = "ul_usage_min_percentage";
    cfgvar = "upload_bandwith_min_percentage";
    desc = "Unless this percentage or more of the upload bandwidth is used, "
           "allow additional upload slots";
    type = guint32;
    data = {
        default = 70;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "download_connecting_timeout";
    desc = "Number of seconds before a download connect attempt "
		   "times out";
    type = guint32; 
    data = {
        default = 30;
        min     = 1;
        max     = 100000; 
    }; 
};

prop = {
    name = "download_push_sent_timeout";
    desc = "Number of seconds before a push request times out";
    type = guint32;
    data = { 
        default = 60;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "download_connected_timeout";
    desc = "Number of seconds before a download times out if no data "
           "is received";
    type = guint32;
    data = {
        default = 60;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_timeout_min";
    desc = "Minimum number of seconds to wait on auto-retry timeouts";
    type = guint32;  
    data = {
        default = 20;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_timeout_max";
    desc = "Maximum number of seconds to wait on auto-retry timeouts";
    type = guint32;
    data = {
        default = 120;
        min     = 1;
        max     = 100000;
    };
};
  
prop = {
    name = "download_max_retries";
    desc = "Maximum number of attempts to download a file not "
           "counting HTTP busy indications";
    type = guint32;
    data = {
        default = 256;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_timeout_delay";
    desc = "Delay in seconds before retrying after a connection " 
           "timed out";
    type = guint32;
    data = {
        default = 1200;
        min     = 15;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_busy_delay";
    desc = "Delay in seconds before retrying after getting a 'busy' "
           "response from a host";
    type = guint32;
    data = {  
        default = 60;
        min     = 15;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_refused_delay";
    desc = "Delay in seconds before retrying after getting a 'connection "
           "refused' response from a host";
    type = guint32;
    data = {
        default = 1800;
        min     = 15;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_stopped_delay";
    cfgvar = "download_retry_stopped";
    desc = "Delay in seconds before retrying after a retry stopped "
           "(timed out, connection reset by peer, etc...)";
    type = guint32;
    data = {
        default = 15;
        min     = 15;
        max     = 100000;
    };
};

prop = {
    name = "download_overlap_range";
    desc = "Ammount of bytes to overlap when resuming a download. "
		   "It should be at least 64 bytes for safe resuming, otherwise "
		   "gtk-gnutella will not accept to resume a file for which we "
		   "had no SHA1 known, after a server gives one back.";
    type = guint32;
    data = {
        default = 512;
        min     = 0;
        max     = SOCK_BUFSZ;
    };
};

prop = {
    name = "upload_connecting_timeout";
    desc =  "Number of seconds before an upload times out if no "
            "connection can be established during a push.  It is "
			"also the maximum amount of time we wait to get the "
			"whole HTTP request.";
    type = guint32;
    data = {
        default = 60;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "upload_connected_timeout";
    desc = "Number of seconds after which an upload times out if no data "
           "is transmitted";
    type = guint32;
    data = {
        default = 180;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "search_reissue_timeout";
    desc = "Ammount of seconds to wait before a search is issued again "
           "to see if new results are available.  Be very careful with "
		   "that parameter, and do not set it too low or you will damage "
		   "the Gnutella network.  A delay of half an hour is fine.";
    type = guint32;
    data = {
        default = 1800;
        min     = 600;
        max     = 9999;
    };
};

prop = {
    name = "ban_ratio_fds";
    desc = "Maximum ratio of file descriptors reserved for banning. "
		   "For instance, if your OS gives your 350 file descriptors, "
		   "a ratio of 10 will reserve at most 35 file descriptors.  You "
		   "should ensure you have around 100 file descriptors for "
		   "efficient banning.";
    type = guint32;
    data = {
        default = 25;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "ban_max_fds";
    desc = "Maximum number of file descriptors reserved for banning";
    type = guint32;
    data = {
        default = 100;
        min     = 0;
        max     = 10000;
    };
};

prop = {
    name = "incoming_connecting_timeout";
    desc =  "Number of seconds an incoming connection has "  
            "to start sending out its request";
    type = guint32;
    data = {
        default = 30;
        min     = 5;
        max     = 300;
    };
};

prop = {
    name = "node_connecting_timeout";
    desc =  "Number of seconds before a Gnet connect attempt times "  
            "out if no connection can be established";
    type = guint32;
    data = {
        default = 5;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "node_connected_timeout";
    desc =  "Number of seconds before a Gnet connection times out "
            "if no data is transmitted";
    type = guint32;
    data = {
        default = 45;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "node_sendqueue_size";
    desc = "Maximum size of the sendqueue for the nodes (in bytes). "
           "Must be at lest 150% of the maximum message size";
    type = guint32;
    data = {
        default = 98304;
        min     = 98305;
        max     = 256000;
    };
};

prop = {
    name = "node_tx_flowc_timeout";
    desc = "Maximum number of seconds a node can remain in transmit flow "
           "control before being kicked out.";
    type = guint32;
    data = {
        default = 60;
        min     = 5;
        max     = 100000;
    };
};

prop = {
    name = "max_ttl";
    desc = "Maximum TTL we allow in messages we broadcast.  If a message "
		   "comes in with a TTL greater than that, it will be trimmed down "
		   "to that value.  On Gnutella, the standard is TTL=7, so you "
		   "cannot set a value lower than that.";
    type = guint32;
    data = { 
        default = 10;
        min     = 7;
        max     = 20;
    };
};

prop = {
    name = "my_ttl";
    desc = "The TTL we use in messages we generate.  The default on "
		   "Gnutella is TTL=7.  If you set it to too large a value, you "
		   "run the risk of being trimmed down by fellow gtk-gnutella "
		   "nodes, or kicked out by some other servent.";
    type = guint32;
    data = {
        default = 7;
        min     = 1;
        max     = 15;
    };
};

prop = {
    name = "hard_ttl_limit";
    desc = "Maximum hard TTL limit (hops + TTL) on messages we relay.  This "
		   "should be greater than the standard TTL=7, because it also "
		   "applied to routed-back messages (query hits) that could be "
		   "re-routed in case a connection is lost.  Standard broadcasted "
		   "messages have their TTL limited by the maximum TTL you configure, "
		   "and that limit should be much lower than the value of this "
		   "parameter.";
    type = guint32;
    data = {
        default = 15;
        min     = 9;
        max     = 25;
    };
};

prop = {
    name = "dbg";
    desc = "For development use: debug level";
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 20;
    };
};

prop = {
    name = "stop_host_get";
    desc = "For development use: don't add new hosts to the hostcatcher";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "bw_http_in_enabled";
    cfgvar = "bandwidth_input_limit";
    desc = "Enable bandwidth limitation for incoming HTTP traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_in_enabled;
    };
};

prop = {
    name = "bw_http_out_enabled";
    cfgvar = "bandwidth_output_limit";
    desc = "Enable bandwidth limitation for outgoing HTTP traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_out_enabled;
    };
};

prop = {
    name = "bw_gnet_in_enabled";
    cfgvar = "bandwidth_ginput_limit";
    desc = "Enable bandwidth limitation for incoming Gnet traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_gin_enabled;
    };
};

prop = {
    name = "bw_gnet_out_enabled";
    cfgvar = "bandwidth_goutput_limit";
    desc = "Enable bandwidth limitation for outgoing Gnet traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_gout_enabled;
    };
};

prop = {
    name = "bw_ul_usage_enabled";
    cfgvar = "upload_bandwith_usage_enabled";
    desc = "Enable dynamic upload slots allocation";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "autoclear_downloads";
    cfgvar = "auto_clear_completed_downloads";
    desc = "Auto clear completed downloads";
    type = boolean;  
    data = {
        default = FALSE;
        value   = clear_downloads;
    };
};

prop = {
    name = "search_remove_downloaded";
    desc = "Remove downloaded files from the search result";
    type = boolean;
    data = {
        default = FALSE;
        value   = search_remove_downloaded;
    };
};

prop = {
    name = "force_local_ip";
    desc = "Enable to use [forced_local_ip] as local ip";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "use_netmasks";
    desc = "Try to connect to local networks first";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "download_delete_aborted";
    desc = "Remove files of aborted downloads from disk";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "proxy_connections";
    desc = "Use a proxy to connect to the internet";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "proxy_auth";
    desc = "Use username and password to authenticate to proxy";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "socks_user";
    desc = "Username for proxy";
    type = string;
    data = {
        default = "username";
    };
};

prop = {
    name = "socks_pass";
    desc = "Password for proxy";
    type = string;
    data = {
        default = "password";
    };
};

prop = {
    name = "proxy_ip";
    desc = "IP address of the proxy";
    type = ip;
    data = {
        default = 0x00000000;
    };
};

prop = {
    name = "proxy_port";
    desc = "Port the proxy is listening on";
    type = guint32;
    data = {
        default = 0x0000;
        min     = 0x0000;
        max     = 0xFFFF;
    };
};

prop = {
    name = "proxy_protocol";
    desc = "Protocol the proxy uses";
    type = guint32;
    data = {
        default = PROXY_SOCKSV4;
        min     = 0x1;
        max     = 0x5;
    };
};

prop = {
    name = "max_hosts_cached";
    desc = "Maximum number of hosts in the host catcher";
    type = guint32;
    data = {
        default = 20480;
        min     = 100;
        max     = 100000;
    };
};

prop = {
    name = "hosts_in_catcher";
    desc = "Current number of hosts in hostcatcher";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 100000;
    };
};

prop = {
    name = "max_high_ttl_msg";
    desc = "Amount of tolerable messages above hard TTL limit per node. "
           "See also MAX_HIGH_TTL_RADIUS";
    type = guint32;
    data = {
        default = 10;
        min     = 0;
        max     = 10000;
    };
};

prop = {
    name = "max_high_ttl_radius";
    desc = "Hop radius for counting high TTL limit messages (# hops "
           "lower than...) See also MAX_HIGH_TTL_MSG";
    type = guint32;
    data = {
        default = 2;
        min     = 0;
        max     = 10;
    };
};

prop = {
    name = "bw_http_in";
    cfgvar = "input_bandwidth";
    desc = "Bandwidth limit for incoming HTTP traffic in bytes/sec";
    type = guint32;
    data = {
        default = 1024;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
    name = "bw_http_out";
    cfgvar = "output_bandwidth";
    desc = "Bandwidth limit for outgoing HTTP traffic in bytes/sec";
    type = guint32;
    data = {
        default = 1024;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
     name = "bw_gnet_in";
     cfgvar = "input_gnet_bandwidth";
     desc = "Bandwidth limit for incoming gNet traffic in bytes/sec";
     type = guint32;
     data = {
        default = 1024;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
    name = "bw_gnet_out";
    cfgvar = "output_gnet_bandwidth";
    desc = "Bandwidth limit for outgoing gNet traffic in bytes/sec";
    type = guint32;
    data = {
        default = 1024;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
    name = "search_queries_forward_size";
    desc = "Maximum size of search queries messages we forward to others "
           " (in bytes)";
    type = guint32;
    data = {
        default = 256;
        min     = 64;
        max     = 65536;
    };
};

prop = {
    name = "search_queries_kick_size";
    desc =  "Maximum size of search queries messages we allow, otherwise "
            "close the connection (in bytes)";
    type = guint32;
    data = {
        default = 1024;
        min     = 128;
        max     = 65536;
    };
};

prop = {
    name = "search_answers_forward_size";
    desc = "Maximum size of search answers messages we forward to others "
           "(in bytes)";
    type = guint32;
    data = {
        default = 65536;
        min     = 2048;
        max     = 65536;
    };
};

prop = {
    name = "search_answers_kick_size";
    desc =  "Maximum size of search answers messages we allow, otherwise "
            "close the connection (in bytes)";
    type = guint32;
    data = {
        default = 65536;
        min     = 2048;
        max     = 65536;
    };
};

prop = {
    name = "other_messages_kick_size";
    desc = "Maximum size of unknown messages we allow, otherwise close the "
           "connection (in bytes)";
    type = guint32;
    data = {
        default = 40960;
        min     = 256;
        max     = 65536;
    };
};

prop = {
    name = "hops_random_factor";
    desc = "Random factor for the hops field in search packets we send "
           "between 0 and 3 inclusive)";
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 3;
    };
};

prop = {
    name = "send_pushes";
    desc = "Whether or not to send push requests.  If you are firewalled, "
		   "gtk-gnutella will never send push requests anyway.  If you "
		   "don't let gtk-gnutella send pushes, it will not show search "
		   "results that would require a push.";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "min_dup_msg";
    desc = "Minimum amount of dup messages to enable kicking, per node "
           "(also see [min_dup_ratio])";
    type = guint32;
    data = {
        default = 5;
        min     = 1;
        max     = 99;
    };
};

prop = {
    name = "min_dup_ratio";
    desc = "Minimum ratio of dups on received messages, per node "
           "(between 0.00 and 100.00) (also see [min_dup_msg]) "
           "Note: the value is stored between 0 (0.0) and 10000 (100.0) "
           "in the config file";
    type = guint32;
    data = {
        default = 150;
        min     = 0;
        max     = 10000;
    };
};

prop = {
    name = "scan_extensions";
    cfgvar = "shared_files_extensions";
    desc = "Only files with the given extensions will be shared. "
		   "The special --all-- extension matches all files, even "
		   "if they don't have any extension.  Use with care.";
    type = string;
    data = {
        default = 
          "asf;avi;"
		  "bin;bz2;"
		  "cue;"
		  "deb;divx;"
		  "flc;fli;"
		  "gif;gz;"
		  "ifo;iso;it;"
		  "jpeg;jpg;"
		  "mjpg;mod;mov;mpa;mpg;mpeg;mpega;mp4;mp3;mp2;mp1:mpv;"
		  "ogg;"
		  "qt;"
		  "png;ps;pdf;"
		  "ram;rm;rar;rpm;"
		  "s3m;stm;"
		  "tar;tgz;txt;"
		  "vob;voc;vqf;"
		  "wav;wma;wmv;"
		  "xm;"
		  "zip";
    };
};

prop = {
    name = "save_file_path";
    cfgvar = "store_downloading_files_to";
    desc = "Store incomplete files in this directory";
    type = string;
    data = {
        default = "/tmp";
    };
};

prop = {
    name = "move_file_path";
    cfgvar = "move_downloading_files_to";
    desc = "Move complete files to this directory.  It should be on "
		   "the same filesystemt as the directory where incomplete "
		   "files are saved, because the move of files between the "
		   "two is a synchronous operation that will take a looong time "
		   "if the kernel needs to physically copy the file...";
    type = string;
    data = {
        default = "/tmp";
    };
};

prop = {
    name = "shared_dirs_paths";
    cfgvar = "shared_dirs";
    desc = "Directories which contain shared files";
    type = string;
    data = {
        default = "";
    };
};

prop = {
    name = "local_netmasks_string";
    cfgvar = "local_netmasks";
    desc = "List of networks considered local.  This is a list of "
			"IP addresses, separated by ';'.  The IP address can be "
			"given out fully, as in 192.168.0.1, or be optionally "
			"followed by '/' and a network mask prefix length. "
			"For instance, 192.168.0.1/24 would represent the whole "
			"192.168.0.* network.";
    type = string;
    data = {
        default = "";
    };
};

prop = {
    name = "total_downloads";
    desc = "Total number of completed downloads in this session";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min = 0x00000000;
        max = 0xFFFFFFFF;
    };
};

prop = {
    name = "total_uploads";
    desc = "Total number of completed uploads in this session";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min = 0x00000000;
        max = 0xFFFFFFFF;
    };
};

prop = {
    name = "guid";
    desc = "Global Unique IDentifier of this node";
    type = storage;
    vector_size = 16;
};

prop = {
    name = "use_swarming";
    desc = "Wether or not to use swarming (recommended = YES)";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "use_aggressive_swarming";
    desc = "Whether or not to launch competing downloads when swarming and "
		   "there are many sources available with a few chunks left.";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "dl_minchunksize";
    desc = "Minimum chunk size when swarming.  This is only a hint "
		   "as gtk-gnutella will download less if you only have a few "
		   "bytes to get for a file...";
    type = guint32;
    data = {
	    min = "64*1024";
	    max = "100*1024*1024";
        default = "512*1024";
    };
};

prop = {
    name = "dl_maxchunksize";
    desc = "Maximum chunk size when swarming";
    type = guint32;
    data = {
	    min = "64*1024";
	    max = "1000*1024*1024";
        default = "10*1024*1024";
    };
};


prop = {
    name = "auto_download_identical";
    desc = "Wether or not to automatically queue search results that "
	   "match a file in the download queue";
    type = boolean;
    data = {
	    default = TRUE;
    };
};

prop = {
    name = "strict_sha1_matching";
    desc = "When enabled, SHA1s must match. Otherwise, name and size "
			"will be sufficient";
    type = boolean;
    data = {
	    default = FALSE;
    };
};

prop = {
    name = "use_fuzzy_matching";
    desc = "Use fuzzy file name matching (recommended = NO; only rely on "
		   "SHA1 matching to be safe)";
    type = boolean;
    data = {
	    default = FALSE;
    };
};

prop = {
    name = "fuzzy_threshold";
    desc = "Fuzziness threshold for filename matching (higher = stricter). "
		   "A value of 100 means the filenames must be 100% identical.  A "
		   "value of 0 means any two filenames will always be considered to "
		   "be identical.  The minimum is 50%.";
    type = guint32;
    data = {
	    default = 70;
	    min = 50;
	    max = 100;
    };
};

prop = {
    name = "is_firewalled";
    desc = "Whether gtk-gnutella thinks we're currently firewalled";
    save = FALSE;
    type = boolean;
    data = {
	    default = TRUE;
    };
};

prop = {
    name = "is_inet_connected";
    desc = "Whether gtk-gnutella thinks it's connected to the Internet";
    save = FALSE;
    type = boolean;
    data = {
	    default = TRUE;
    };
};

prop = {
    name = "gnet_compact_query";
    desc = "Remove unnecessary ballast from query string before processing "
           "or forwarding them. Reduces traffic at the cost of little CPU time";
    type = boolean;
    data = {
	    default = TRUE;
    };
};

prop = {
    name = "download_optimistic_start";
    desc = "Also use sources that don't provide a SHA1 value for the first "
           "chunk of a file. This dramatically reduces the 'No URN on server' "
           "messages, but may result in overlap problems later if the first "
           "chunk was actually from a different file. Use with caution.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "mark_ignored";
    desc = "Mark files that would be ignored when downloaded. This uses a "
           "little additional CPU power so it's off by default. If you "
           "don't have a very slow box, you might want to turn this on.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "library_rebuilding";
    desc = "Whether gtk-gnutella is currently rebuilding its library "
           "in the background";
    save = FALSE;
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "sha1_rebuilding";
    desc = "Whether gtk-gnutella is currently computing SHA1 of shared "
           "files in the background";
    save = FALSE;
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "sha1_verifying";
    desc = "Whether gtk-gnutella is currently verifying SHA1 of downloaded "
           "files in the background";
    save = FALSE;
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "prefer_compressed_gnet";
    desc = "If active, only compressed incoming connections are allowed after "
           "the minimum number of connections has been established. Always "
	   "allows for one non-compressed connection.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "online_mode";
    desc = "If deactivated only uploads and downloads will continue. All "
           "gNet connections are disabled/terminated.";
    type = boolean;
    data = {
        default = TRUE;
    };
};
