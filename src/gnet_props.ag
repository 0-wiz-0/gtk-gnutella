autogen definitions 'props.tpl';

/*
 * $Id$
 */

uses = "sockets.h";
uses = "gnet.h";
uses = "bsched.h";

property_set = "gnet_property";
func_prefix  = "gnet_prop";
offset       = "(NO_PROP+1)";

prop = {
    name = "reading_hostfile";
    desc = "Indicates whether the hostcache file is being read";
    type = boolean;
    save = FALSE;
    data = {  
        default = FALSE;
    };
};

prop = {
    name = "reading_ultrafile";
    desc = "Indicates whether the ultracache file is being read";
    type = boolean;
    save = FALSE;
    data = {  
        default = FALSE;
    };
};

prop = {
    name = "ancient_version";
    desc = "Indicates that gtk-gnutella finds the version you run "
           "very very old";
    type = boolean;
    save = FALSE;
    data = { 
        default = FALSE;
    };
};
  
prop = {
    name = "new_version_str";
    desc = "Gtk-gnutella found a newer version on the gNet and gives "
           "information about it here";
    type = string;
    save = FALSE;
    data = { 
        default = NULL;
    };
};

prop = {
    name = "up_connections";
    desc = "Try to keep at least this number of connections to other " 
           "servents of the same kind as we are (normal or ultra nodes). "
		   "This should be smaller than the maximum amount "
		   "of connections to allow incoming connections.";
    type = guint32;
    data = {
        default = 3;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "normal_connections";
    desc = "When in ultrapeer mode, try to keep at least this number of "
		   "connections to normal servents.  This should be smaller than "
		   "the maximum amount of connections to allow incoming connections.";
    type = guint32;
    data = {
        default = 2;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "max_connections";
    desc = "Don't allow more than this number of connections to other "
           "servents.  As a rule of thumb you should reserve 1kb/s "
	       "bandwidth per connection. Never use up all your bandwidth, "
	       "leave a little space for TCP/IP overhead. It's not "
           "advisable that you set this to a value larger than 10.";
    type = guint32;
    data = {
        default = 4;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "node_leaf_count";
    desc = "Number of leaf nodes currently connected.";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "node_normal_count";
    desc = "Number of normal nodes currently connected.";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "node_ultra_count";
    desc = "Number of ultra nodes currently connected.";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name ="max_downloads";
    cfgvar = "max_simultaneous_downloads";
    desc = "Don't start more than this number of parallel downloads.  "
		   "Others will remain in the queue waiting for a download slot.";
    type = guint32;
    data = {
        default = 50;
        min     = 0;
        max     = 999;
    };
};

prop = {
    name = "max_host_downloads";
    cfgvar = "max_simultaneous_host_downloads";
    desc = "Don't make more connections than given here to a single host "
           "to download a file.  Be nice to others, and leave it at "
		   "the default value (1).";
    type = guint32;
    data = {
        default = 1;
        min     = 1;
        max     = 10;
    };
};

prop = {
    name = "max_uploads";
    cfgvar = "max_simultaneous_uploads";
    desc = "Don't allow more than this number of uploads in total. "
		"This also defines the amount of PARQ queues that will be used. "
		"You should at least set it to 2.";
    type = guint32;
    data = {
        default = 4;
        value   = max_uploads;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "max_uploads_ip";
    desc = "Don't upload more than this number of files in parallel to a "
           "single host";
    type = guint32;
    data = {
        default = 1;
        min     = 1;
        max     = 100; 
    }; 
};

prop = {
    name = "local_ip";
    desc = "Local IP address last determined";
    save = TRUE;
    type = ip;
    data = {
        default = 0x00000000;
    };
};

prop = {
    name = "current_ip_stamp";
    desc = "When the current IP address was determined";
	save = TRUE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "average_ip_uptime";
    desc = "Average uptime with the same IP address";
	save = TRUE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "start_stamp";
    desc = "Timestamp at which servent was started";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "average_servent_uptime";
    desc = "Average servent uptime, in seconds";
	save = TRUE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "listen_port";
    desc = "Local port gtk-gnutella is listening on. Your ISP may "
			"block or choke traffic on port 6346 so it would be a "
			"good idea to change it to something in the range of "
			"1024-65535.  Don't forget to update your firewall port "
			"forwarding / opening, as necessary.  Note that by default, "
			"the port 6346 is not used to guard against undue censorship.";
    type = guint32;
    data = {
        default = 8436;
        min     = 0x0000;
        max     = 0xFFFF;
    };
};

prop = {
    name = "forced_local_ip";
    desc = "Use this IP address as source address if 'force local ip' "
           "is activated";
    type = ip;
    data = {
        default = 0x00000000;
    }; 
};

prop = {
    name = "connection_speed";
    desc = "The connection bandwidth reported to other hosts";
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 2000;
    };
};

prop = {
    name = "query_response_max_items";
    cfgvar = "limit_search_results";
    desc = "Return at most this number of results to a query, using as many "
		   "query hit packets as necessary.  To avoid network flooding, keep "
		   "this to a reasonable value.";
    type = guint32;
    data = { 
        default = 50;
        value   = search_max_items;
        min     = 1;
        max     = 500;
    };
};

prop = {
    name = "ul_usage_min_percentage";
    cfgvar = "upload_bandwith_min_percentage";
    desc = "Unless this percentage or more of the upload bandwidth is used, "
           "allow additional upload slots";
    type = guint32;
    data = {
        default = 70;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "download_connecting_timeout";
    desc = "Number of seconds before a download connect attempt "
		   "times out";
    type = guint32; 
    data = {
        default = 30;
        min     = 1;
        max     = 100000; 
    }; 
};

prop = {
    name = "download_push_sent_timeout";
    desc = "Number of seconds before a push request times out";
    type = guint32;
    data = { 
        default = 60;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "download_connected_timeout";
    desc = "Number of seconds before a download times out if no data "
           "is received";
    type = guint32;
    data = {
        default = 60;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_timeout_min";
    desc = "Minimum number of seconds to wait on auto-retry timeouts";
    type = guint32;  
    data = {
        default = 20;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_timeout_max";
    desc = "Maximum number of seconds to wait on auto-retry timeouts";
    type = guint32;
    data = {
        default = 120;
        min     = 1;
        max     = 100000;
    };
};
  
prop = {
    name = "download_max_retries";
    desc = "Maximum number of attempts to download a file not "
           "counting HTTP busy indications";
    type = guint32;
    data = {
        default = 256;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_timeout_delay";
    desc = "Delay in seconds before retrying after a connection " 
           "timed out";
    type = guint32;
    data = {
        default = 1200;
        min     = 15;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_busy_delay";
    desc = "Delay in seconds before retrying after getting a 'busy' "
           "response from a host";
    type = guint32;
    data = {  
        default = 60;
        min     = 15;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_refused_delay";
    desc = "Delay in seconds before retrying after getting a 'connection "
           "refused' response from a host";
    type = guint32;
    data = {
        default = 1800;
        min     = 15;
        max     = 100000;
    };
};

prop = {
    name = "download_retry_stopped_delay";
    cfgvar = "download_retry_stopped";
    desc = "Delay in seconds before retrying after a retry stopped "
           "(timed out, connection reset by peer, etc...)";
    type = guint32;
    data = {
        default = 15;
        min     = 15;
        max     = 100000;
    };
};

prop = {
    name = "download_overlap_range";
    desc = "Amount of bytes to overlap when resuming a download. "
		   "It should be at least 64 bytes for safe resuming, otherwise "
		   "gtk-gnutella will not accept to resume a file for which we "
		   "had no SHA1 known, after a server gives one back.";
    type = guint32;
    data = {
        default = 512;
        min     = 0;
        max     = SOCK_BUFSZ;
    };
};

prop = {
    name = "upload_connecting_timeout";
    desc =  "Number of seconds before an upload times out if no "
            "connection can be established during a push.  It is "
			"also the maximum amount of time we wait to get the "
			"whole HTTP request.";
    type = guint32;
    data = {
        default = 60;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "upload_connected_timeout";
    desc = "Number of seconds after which an upload times out if no data "
           "is transmitted";
    type = guint32;
    data = {
        default = 180;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "search_reissue_timeout";
    desc = "Amount of seconds to wait before a search is issued again "
           "to see if new results are available.  Be very careful with "
		   "this parameter, and do not set it too low or you will damage "
		   "the Gnutella network.  A delay of half an hour is fine.";
    type = guint32;
    data = {
        default = 1800;
        min     = 600;
        max     = 9999;
    };
};

prop = {
    name = "ban_ratio_fds";
    desc = "Maximum ratio of file descriptors reserved for banning. "
		   "For instance, if your OS gives you 350 file descriptors, "
		   "a ratio of 10 will reserve at most 35 file descriptors.  You "
		   "should ensure you have around 100 file descriptors for "
		   "efficient banning.";
    type = guint32;
    data = {
        default = 25;
        min     = 0;
        max     = 100;
    };
};

prop = {
    name = "ban_max_fds";
    desc = "Maximum number of file descriptors reserved for banning";
    type = guint32;
    data = {
        default = 100;
        min     = 0;
        max     = 10000;
    };
};

prop = {
    name = "max_banned_fd";
    desc = "Number of file descriptors we'll actually be using for banning";
    type = guint32;
	save = FALSE;
    data = {
        default = 100;
    };
};

prop = {
    name = "incoming_connecting_timeout";
    desc =  "Number of seconds an incoming connection has "  
            "to start sending out its request";
    type = guint32;
    data = {
        default = 30;
        min     = 5;
        max     = 300;
    };
};

prop = {
    name = "node_connecting_timeout";
    desc =  "Number of seconds before a Gnet connect attempt times "  
            "out if no connection can be established";
    type = guint32;
    data = {
        default = 5;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "node_connected_timeout";
    desc =  "Number of seconds before a Gnet connection times out "
            "if no data is transmitted";
    type = guint32;
    data = {
        default = 45;
        min     = 1;
        max     = 100000;
    };
};

prop = {
    name = "node_sendqueue_size";
    desc = "Maximum size of the sendqueue for the nodes (in bytes). "
           "Must be at least 150% of the maximum message size";
    type = guint32;
    data = {
        default = 98304;
        min     = 98305;
        max     = 256000;
    };
};

prop = {
    name = "node_tx_flowc_timeout";
    desc = "Maximum number of seconds a node can remain in transmit flow "
           "control before being kicked out.";
    type = guint32;
    data = {
        default = 60;
        min     = 5;
        max     = 100000;
    };
};

prop = {
    name = "node_rx_flowc_ratio";
    desc = "Maximum percentage of time over 5 minutes that our node can remain "
           "in flow control remotely before dropping the connection.  This "
		   "only works with nodes that will send us an hops-flow message when "
		   "they are flow-controlling us.";
    type = guint32;
    data = {
        default = 50;
        min     = 10;
        max     = 100;
    };
};

prop = {
    name = "max_ttl";
    desc = "Maximum TTL we allow in messages we broadcast.  If a message "
		   "comes in with a TTL greater than that, it will be trimmed down "
		   "to that value.  On Gnutella, the standard is TTL=7, so you "
		   "cannot set a value lower than that.";
    type = guint32;
    data = { 
        default = 10;
        min     = 7;
        max     = 20;
    };
};

prop = {
    name = "my_ttl";
    desc = "The TTL we use in messages we generate.  The default on "
		   "Gnutella is TTL=7.  If you set it to too large a value, you "
		   "run the risk of being trimmed down by fellow gtk-gnutella "
		   "nodes, or kicked out by some other servent.";
    type = guint32;
    data = {
        default = 7;
        min     = 1;
        max     = 15;
    };
};

prop = {
    name = "hard_ttl_limit";
    desc = "Maximum hard TTL limit (hops + TTL) on messages we relay.  This "
		   "should be greater than the standard TTL=7, because it is also "
		   "applied to routed-back messages (query hits) that could be "
		   "re-routed in case a connection is lost.  Standard broadcasted "
		   "messages have their TTL limited by the maximum TTL you configure, "
		   "and that limit should be much lower than the value of this "
		   "parameter.";
    type = guint32;
    data = {
        default = 15;
        min     = 9;
        max     = 25;
    };
};

prop = {
    name = "dbg";
    desc = "For development use: debug level";
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 20;
    };
};

prop = {
    name = "lib_debug";
    desc = "Debug level for code shared between gui and core";
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "track_props";
    desc = "For development use: track properties";
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 20;
    };
};



prop = {
    name = "stop_host_get";
    desc = "For development use: don't add new hosts to the hostcatcher";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "bw_http_in_enabled";
    cfgvar = "bandwidth_input_limit";
    desc = "Enable bandwidth limitation for incoming HTTP traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_in_enabled;
    };
};

prop = {
    name = "bw_http_out_enabled";
    cfgvar = "bandwidth_output_limit";
    desc = "Enable bandwidth limitation for outgoing HTTP traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_out_enabled;
    };
};

prop = {
    name = "bw_gnet_in_enabled";
    cfgvar = "bandwidth_ginput_limit";
    desc = "Enable bandwidth limitation for incoming Gnet traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_gin_enabled;
    };
};

prop = {
    name = "bw_gnet_leaf_in_enabled";
    cfgvar = "bandwidth_glinput_limit";
    desc = "Enable bandwidth limitation for incoming Gnet leaf traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_glin_enabled;
    };
};

prop = {
    name = "bw_gnet_out_enabled";
    cfgvar = "bandwidth_goutput_limit";
    desc = "Enable bandwidth limitation for outgoing Gnet traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_gout_enabled;
    };
};

prop = {
    name = "bw_gnet_leaf_out_enabled";
    cfgvar = "bandwidth_gloutput_limit";
    desc = "Enable bandwidth limitation for outgoing Gnet leaf traffic";
    type = boolean;
    data = {
        default = FALSE;
        value   = bws_glout_enabled;
    };
};

prop = {
    name = "bw_ul_usage_enabled";
    cfgvar = "upload_bandwith_usage_enabled";
    desc = "Enable dynamic upload slots allocation";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "bw_allow_stealing";
    desc = "Allow HTTP and Gnutella to grab whatever bandwidth the other "
			"is not using.  If FALSE, unused bandwidth is lost.";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "autoclear_completed_downloads";
    cfgvar = "auto_clear_completed_downloads";
    desc = "Auto clear completed downloads";
    type = boolean;  
    data = {
        default = FALSE;
        value   = clear_complete_downloads;
    };
};

prop = {
    name = "autoclear_failed_downloads";
    cfgvar = "auto_clear_failed_downloads";
    desc = "Auto clear failed downloads";
    type = boolean;  
    data = {
        default = FALSE;
        value   = clear_failed_downloads;
    };
};

prop = {
    name = "search_remove_downloaded";
    desc = "Remove downloaded files from the search result";
    type = boolean;
    data = {
        default = FALSE;
        value   = search_remove_downloaded;
    };
};

prop = {
    name = "force_local_ip";
    desc = "Enable to use [forced_local_ip] as local ip";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "use_netmasks";
    desc = "Try to connect to local networks first";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "allow_private_network_connection";
    desc =	"Check this button if you want to use GTK-Gnutella on your "
			"Local Area Network. RFC1918 will be ignored.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "use_ip_tos";
    desc =	"Check this button if you want GTK-Gnutella to use IP TOS to "
			"differentiate interactive, normal and bulk data. This is "
			"probably a good idea in most cases, and can particularly help "
			"with badly misconfigured hosts, LANs, and ISPs.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "download_delete_aborted";
    desc = "Remove files of aborted downloads from disk";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
	/* FIXME: This property is deprecated. Remove it after the next release */
    name = "proxy_connections";
    desc = "DEPRECATED and automatically set to TRUE. "
		"Use a proxy to connect to the internet";
	save = FALSE;
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "proxy_auth";
    desc = "Use username and password to authenticate to proxy";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "socks_user";
    desc = "Username for proxy";
    type = string;
    data = {
        default = "username";
    };
};

prop = {
    name = "socks_pass";
    desc = "Password for proxy";
    type = string;
    data = {
        default = "password";
    };
};

prop = {
    name = "proxy_ip";
    desc = "IP address of the proxy";
    type = ip;
    data = {
        default = 0x00000000;
    };
};

prop = {
    name = "proxy_port";
    desc = "Port the proxy is listening on";
    type = guint32;
    data = {
        default = 0x0000;
        min     = 0x0000;
        max     = 0xFFFF;
    };
};

prop = {
    name = "proxy_protocol";
    desc = "Protocol the proxy uses";
    type = multichoice;
    data = {
        default = PROXY_NONE;
    };
    choice = {
        name = "None";
        value = PROXY_NONE;
    };
    choice = {
        name = "HTTP";
        value = PROXY_HTTP;
    };
    choice = {
        name = "SOCKS v4";
        value = PROXY_SOCKSV4;
    };
    choice = {
        name = "SOCKS v5";
        value = PROXY_SOCKSV5;
    };
};

prop = {
    name = "max_hosts_cached";
    desc = "Maximum number of hosts in the regular node catcher";
    type = guint32;
    data = {
        default = 20480;
        min     = 100;
        max     = 100000;
    };
};

prop = {
    name = "hosts_in_catcher";
    desc = "Current number of hosts in regular node catcher";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 100000;
    };
};

prop = {
    name = "hosts_in_ultra_catcher";
    desc = "Current number of hosts in ultra node catcher";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 100000;
    };
};

prop = {
    name = "max_ultra_hosts_cached";
    desc = "Maximum number of hosts in the ultra node catcher";
    type = guint32;
    data = {
        default = 20480;
        min     = 100;
        max     = 100000;
    };
};

prop = {
    name = "max_high_ttl_msg";
    desc = "Amount of tolerable messages above hard TTL limit per node. "
           "See also MAX_HIGH_TTL_RADIUS";
    type = guint32;
    data = {
        default = 10;
        min     = 0;
        max     = 10000;
    };
};

prop = {
    name = "max_high_ttl_radius";
    desc = "Hop radius for counting high TTL limit messages (# hops "
           "lower than...) See also MAX_HIGH_TTL_MSG";
    type = guint32;
    data = {
        default = 2;
        min     = 0;
        max     = 10;
    };
};

prop = {
    name = "bw_http_in";
    cfgvar = "input_bandwidth";
    desc = "Bandwidth limit for incoming HTTP traffic in bytes/sec";
    type = guint32;
    data = {
        default = 8192;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
    name = "bw_http_out";
    cfgvar = "output_bandwidth";
    desc = "Bandwidth limit for outgoing HTTP traffic in bytes/sec";
    type = guint32;
    data = {
        default = 8192;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
     name = "bw_gnet_in";
     cfgvar = "input_gnet_bandwidth";
     desc = "Bandwidth limit for incoming gNet traffic in bytes/sec";
     type = guint32;
     data = {
        default = 8192;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
    name = "bw_gnet_out";
    cfgvar = "output_gnet_bandwidth";
    desc = "Bandwidth limit for outgoing gNet traffic in bytes/sec";
    type = guint32;
    data = {
        default = 8192;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
     name = "bw_gnet_lin";
     cfgvar = "input_gnet_leaf_bandwidth";
     desc = "Bandwidth limit for incoming gNet leaf traffic in bytes/sec. "
			"When running as an ultra node, this bandwidth is stolen "
			"from the regular HTTP traffic if the shaper for leaves is "
			"enabled.";
     type = guint32;
     data = {
        default = 3072;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
    name = "bw_gnet_lout";
    cfgvar = "output_gnet_leaf_bandwidth";
    desc = "Bandwidth limit for outgoing gNet leaf traffic in bytes/sec. "
			"When running as an ultra node, this bandwidth is stolen "
			"from the regular HTTP traffic, if the shaper for leaves is "
			"enabled.";
    type = guint32;
    data = {
        default = 2048;
        min     = 1024;
        max     = BS_BW_MAX;
    };
};

prop = {
    name = "search_queries_forward_size";
    desc = "Maximum size of search queries messages we forward to others "
           " (in bytes)";
    type = guint32;
    data = {
        default = 256;
        min     = 64;
        max     = 65536;
    };
};

prop = {
    name = "search_queries_kick_size";
    desc =  "Maximum size of search queries messages we allow, otherwise "
            "close the connection (in bytes)";
    type = guint32;
    data = {
        default = 1024;
        min     = 128;
        max     = 65536;
    };
};

prop = {
    name = "search_answers_forward_size";
    desc = "Maximum size of search answers messages we forward to others "
           "(in bytes)";
    type = guint32;
    data = {
        default = 65536;
        min     = 2048;
        max     = 65536;
    };
};

prop = {
    name = "search_answers_kick_size";
    desc =  "Maximum size of search answers messages we allow, otherwise "
            "close the connection (in bytes)";
    type = guint32;
    data = {
        default = 65536;
        min     = 2048;
        max     = 65536;
    };
};

prop = {
    name = "other_messages_kick_size";
    desc = "Maximum size of unknown messages we allow, otherwise close the "
           "connection (in bytes)";
    type = guint32;
    data = {
        default = 40960;
        min     = 256;
        max     = 65536;
    };
};

prop = {
    name = "hops_random_factor";
    desc = "Random factor for the hops field in search packets we send "
           "between 0 and 3 inclusive)";
    type = guint32;
    data = {
        default = 0;
        min     = 0;
        max     = 3;
    };
};

prop = {
    name = "send_pushes";
    desc = "Whether or not to send push requests.  If you are firewalled, "
		   "gtk-gnutella will never send push requests anyway.  If you "
		   "don't let gtk-gnutella send pushes, it will not show search "
		   "results that would require a push.";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "min_dup_msg";
    desc = "Minimum amount of dup messages to enable kicking, per node "
           "(also see [min_dup_ratio])";
    type = guint32;
    data = {
        default = 5;
        min     = 1;
        max     = 99;
    };
};

prop = {
    name = "min_dup_ratio";
    desc = "Minimum ratio of dups on received messages, per node "
           "(between 0.00 and 100.00) (also see [min_dup_msg]) "
           "Note: the value is stored between 0 (0.0) and 10000 (100.0) "
           "in the config file";
    type = guint32;
    data = {
        default = 150;
        min     = 0;
        max     = 10000;
    };
};

prop = {
    name = "scan_extensions";
    cfgvar = "shared_files_extensions";
    desc = "Only files with the given extensions will be shared. "
		   "The special --all-- extension matches all files, even "
		   "if they don't have any extension.  Use with care.";
    type = string;
    data = {
        default = 
          "asf;avi;"
		  "bin;bz2;"
		  "cue;"
		  "deb;divx;doc;"
		  "flc;fli;"
		  "gif;gz;"
		  "ifo;iso;it;"
		  "jpeg;jpg;"
		  "mjpg;mod;mov;mpa;mpg;mpeg;mpega;mp4;mp3;mp2;mp1:mpv;"
          "nes;"
		  "ogg;ogm;"
		  "qt;"
		  "png;ps;pdf;"
		  "ram;rm;rar;rpm;rom;"
		  "s3m;smc;smd;stm;"
		  "tar;tgz;txt;"
		  "vob;voc;vqf;"
		  "wav;wma;wmv;"
		  "xm;"
		  "zip";
    };
};

prop = {
    name = "scan_ignore_symlink_dirs";
    desc = "Ignore symbolically linked directories when scanning files to "
           "share.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "scan_ignore_symlink_regfiles";
    desc = "Ignore symbolically linked regular files when scanning files to "
           "share.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "save_file_path";
    cfgvar = "store_downloading_files_to";
    desc = "Store incomplete files in this directory";
    type = string;
    data = {
        default = "/tmp";
    };
};

prop = {
    name = "move_file_path";
    cfgvar = "move_downloading_files_to";
    desc = "Move complete files to this directory. "
		   "If this is set to the SAME directory as the incomplete or "
		   "corrupted files, files will be renamed with a trailing .OK";
    type = string;
    data = {
        default = "/tmp";
    };
};

prop = {
    name = "bad_file_path";
    cfgvar = "move_corrupted_files_to";
    desc = "Move corrupted, downloaded files to this directory. "
		   "If this is set to the SAME directory as the incomplete or "
		   "completed files, files will be renamed with a trailing .BAD";
    type = string;
    data = {
        default = "/tmp";
    };
};

prop = {
    name = "shared_dirs_paths";
    cfgvar = "shared_dirs";
    desc = "Directories which contain shared files";
    type = string;
    data = {
        default = "";
    };
};

prop = {
    name = "local_netmasks_string";
    cfgvar = "local_netmasks";
    desc = "List of networks considered local.  This is a list of "
			"IP addresses, separated by ';'.  The IP address can be "
			"given out fully, as in 192.168.0.1, or be optionally "
			"followed by '/' and a network mask prefix length. "
			"For instance, 192.168.0.1/24 would represent the whole "
			"192.168.0.* network.";
    type = string;
    data = {
        default = "";
    };
};

prop = {
    name = "total_downloads";
    desc = "Total number of completed downloads in this session";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min = 0x00000000;
        max = 0xFFFFFFFF;
    };
};

prop = {
    name = "ul_running";
    desc = "Number of running uploads";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min = 0x00000000;
        max = 0xFFFFFFFF;
    };
};

prop = {
    name = "ul_registered";
    desc = "Number of registered (pending) uploads";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min = 0x00000000;
        max = 0xFFFFFFFF;
    };
};

prop = {
    name = "total_uploads";
    desc = "Total number of completed uploads in this session";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
        min = 0x00000000;
        max = 0xFFFFFFFF;
    };
};

prop = {
    name = "guid";
    desc = "Global Unique IDentifier of this node";
    type = storage;
    vector_size = 16;
};

prop = {
    name = "use_swarming";
    desc = "Whether or not to use swarming (recommended = YES)";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "use_aggressive_swarming";
    desc = "Whether or not to launch competing downloads when swarming and "
		   "there are many sources available with a few chunks left.";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "dl_minchunksize";
    desc = "Minimum chunk size when swarming.  This is only a hint "
		   "as gtk-gnutella will download less if you only have a few "
		   "bytes to get for a file...";
    type = guint32;
    data = {
	    min = "64*1024";
	    max = "100*1024*1024";
        default = "512*1024";
    };
};

prop = {
    name = "dl_maxchunksize";
    desc = "Maximum chunk size when swarming";
    type = guint32;
    data = {
	    min = "64*1024";
	    max = "1000*1024*1024";
        default = "10*1024*1024";
    };
};


prop = {
    name = "auto_download_identical";
    desc = "Whether or not to automatically queue search results that "
	   "match a file in the download queue";
    type = boolean;
    data = {
	    default = TRUE;
    };
};

prop = {
    name = "strict_sha1_matching";
    desc = "When enabled, SHA1s must match. Otherwise, name and size "
			"will be sufficient";
    type = boolean;
    data = {
	    default = FALSE;
    };
};

prop = {
    name = "use_fuzzy_matching";
    desc = "Use fuzzy file name matching (recommended = NO; only rely on "
		   "SHA1 matching to be safe)";
    type = boolean;
    data = {
	    default = FALSE;
    };
};

prop = {
    name = "fuzzy_threshold";
    desc = "Fuzziness threshold for filename matching (higher = stricter). "
		   "A value of 100 means the filenames must be 100% identical.  A "
		   "value of 0 means any two filenames will always be considered to "
		   "be identical.  The minimum is 50%.";
    type = guint32;
    data = {
	    default = 70;
	    min = 50;
	    max = 100;
    };
};

/*
 * NB: we make is_firewalled a persistent property for the following reasons:
 *
 * + If they were not firewalled once, chances are that they will remain so.
 * + Every hour, we monitor incoming connections, and if we receive none, we
 *   will activate the firewalled mode.
 */

prop = {
    name = "is_firewalled";
    desc = "Whether gtk-gnutella thinks we're currently firewalled";
    save = TRUE;
    type = boolean;
    data = {
	    default = TRUE;
    };
};

prop = {
    name = "is_inet_connected";
    desc = "Whether gtk-gnutella thinks it's connected to the Internet";
    save = FALSE;
    type = boolean;
    data = {
	    default = TRUE;
    };
};

prop = {
    name = "gnet_compact_query";
    desc = "Remove unnecessary ballast from query string before processing "
           "or forwarding them. Reduces traffic at the cost of little CPU time";
    type = boolean;
    data = {
	    default = TRUE;
    };
};

prop = {
    name = "download_optimistic_start";
    desc = "Also use sources that don't provide a SHA1 value for the first "
           "chunk of a file. This dramatically reduces the 'No URN on server' "
           "messages, but may result in overlap problems later if the first "
           "chunk was actually from a different file. Use with caution.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "mark_ignored";
    desc = "Mark files that would be ignored when downloaded. This uses a "
           "little additional CPU power so it's off by default. If you "
           "don't have a very slow box, you might want to turn this on.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "library_rebuilding";
    desc = "Whether gtk-gnutella is currently rebuilding its library "
           "in the background";
    save = FALSE;
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "sha1_rebuilding";
    desc = "Whether gtk-gnutella is currently computing SHA1 of shared "
           "files in the background";
    save = FALSE;
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "sha1_verifying";
    desc = "Whether gtk-gnutella is currently verifying SHA1 of downloaded "
           "files in the background";
    save = FALSE;
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "file_moving";
    desc = "Whether gtk-gnutella is currently moving files across "
           "filesystems or simply copying in the background";
    save = FALSE;
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "prefer_compressed_gnet";
    desc = "If active, only compressed incoming connections are allowed after "
           "the minimum number of connections has been established. Always "
	   "allows for one non-compressed connection.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "online_mode";
    desc = "If deactivated, only uploads and downloads will continue. All "
           "gNet connections are disabled/terminated.";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "download_require_urn";
    desc = "Whether gtk-gnutella should make sure the server confirms the "
           "URN of the file we're requesting when it is known locally and "
		   "a traditional request by name is used (i.e. gtk-gnutella is not "
		   "issuing a /uri-res/N2R? request).  When set, it supersedes the "
		   "optimistic first chunk setting.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "download_require_server_name";
    desc = "Whether gtk-gnutella should make sure the server gives us "
           "back a non-empty identifying token.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "max_ultrapeers";
    desc = "Maximum amount of Ultrapeers we should connect to as a leaf.";
    type = guint32;
    data = {
        default = 3;
        min = 1;
        max = 4;
    };
};

prop = {
    name = "max_leaves";
    desc = "Maximum amount of leaves we can accept.";
    type = guint32;
    data = {
        default = 15;
        min = 5;
        max = 1000;
    };
};

prop = {
    name = "configured_peermode";
    desc = "The peer mode you want to operate as for gtk-gnutella.  When auto "
		"is selected, gtk-gnutella will start as a leaf node and may be "
		"promoted to an ultra node if bandwidth and uptime permits, provided "
		"that you are not firewalled.";
    type = multichoice;
    data = {
        default = 3;
    };
    choice = {
        name = "auto (recommended)";
        value = 3;
    };
    choice = {
        name = "ultra node";
        value = 2;
    };
    choice = {
        name = "leaf node";
        value = 0;
    };
    choice = {
        name = "legacy node (avoid)";
        value = 1;
    };
};

prop = {
    name = "current_peermode";
    desc = "Current peer mode for gtk-gnutella";
	save = FALSE;
    type = multichoice;
    data = {
        default = 0;
    };
    choice = {
        name = "ultra node";
        value = 2;
    };
    choice = {
        name = "normal node";
        value = 1;
    };
    choice = {
        name = "leaf node";
        value = 0;
    };
};

prop = {
    name = "sys_nofile";
    desc = "How many file descriptors a process can open.";
	save = FALSE;
    type = guint32;
    data = {
        default = 1024;
    };
};

prop = {
    name = "sys_physmem";
    desc = "How many KB of physical memory is available.";
	save = FALSE;
    type = guint32;
    data = {
        default = 65536;
    };
};

prop = {
    name = "dl_queue_count";
    desc = "How many downloads are currently held in the queue.";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "dl_running_count";
    desc = "How many downloads are currently running "
			"(downloading / connecting).";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "dl_active_count";
    desc = "How many downloads are currently active.";
    save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "dl_qalive_count";
    desc = "How many queued downloads are currently responsive "
			"(remote servent answering requests).";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "dl_byte_count";
    desc = "Amount of bytes downloaded so far, HTTP headers notwithstanding.";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "ul_byte_count";
    desc = "Amount of bytes uploaded so far, HTTP headers notwithstanding.";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "pfsp_server";
    desc = "Whether gtk-gnutella should serve partial files whilst they are "
			"still incompletely downloaded.  Recommended for network's health "
			"unless you already share many files, in which case it does no "
			"harm to leave it in, but will not matter as much.";
    type = boolean;
    data = {
        default = TRUE;
    };
};

prop = {
    name = "pfsp_first_chunk";
    desc = "When partial file sharing (PFSP) is enabled, gtk-gnutella will "
			"strive to download chunks in a random order, to maximize the "
			"spreading of the file in the network.  However, this makes "
			"auditing (file type, pre-viewing, etc...) of the file impossible. "
			"This field sets the size in bytes of the first chunk of data "
			"that should be continuously downloaded at the beginning of the "
			"file.  Don't set it too large.";
    type = guint32;
    data = {
        default = 524288;
    };
};

prop = {
    name = "fuzzy_filter_dmesh";
    desc = "Whether to apply a fuzzy filter on download mesh entries.  The"
			"purpose of this filtering is to remove entries whose names "
			"are too different to be sensibly part of the same mesh. "
			"When activated, your mesh will probably be more consistent "
			"at the cost of extra CPU time, and at the cost of losing "
			"some valid entries in the process.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "crawler_visit_count";
    desc = "Number of crawler visits during this session";
	save = FALSE;
    type = guint32;
    data = {
        default = 0;
    };
};

prop = {
    name = "host_runs_ntp";
    desc = "Whether the clock of this host is kept accurate via NTP. "
		"When you enable this, the computed clock skew is ignored.";
    type = boolean;
    data = {
        default = FALSE;
    };
};

prop = {
    name = "clock_skew";
    desc = "The signed clock skew of this host compared to absolute time. "
		"Adding this skew to the host clock should give the true time.";
    type = guint32;
    data = {
        default = 0;
    };
};

