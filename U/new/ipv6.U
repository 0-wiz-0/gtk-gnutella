?RCS: $Id$
?RCS:
?RCS: @COPYRIGHT@
?RCS:
?MAKE:d_ipv6: cc ccflags ldflags rm cat
?MAKE:	-pick add $@ %<
?S:d_ipv6:
?S: This variable conditionally defines USE_IPV6.
?S:.
?C:USE_IPV6:
?C:  This symbol is defined when IPv6 can be used
?C:.
?H:#$d_ipv6 USE_IPV6
?H:.
?LINT:change d_ipv6
: determine whether IPv6 can be used
echo " "
echo "Checking whether IPv6 can be used ..." >&4
d_ipv6="$define"
$cat >try.c <<'EOC'
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#define STATIC_ASSERT(x)	\
	do { switch (0) { case ((x) ? 1 : 0): case 0: break; } } while(0)

int main(void)
{
	struct sockaddr_in6 sin6;
	static struct in6_addr in6;

	sin6.sin6_family = AF_INET6;
	sin6.sin6_port = 6346;
	sin6.sin6_flowinfo = 23UL;
	sin6.sin6_scope_id = 42UL;
	sin6.sin6_addr = in6;
	sin6.sin6_addr.s6_addr[0] = in6.s6_addr[0];

	STATIC_ASSERT(sizeof in6 == sizeof sin6.sin6_addr);
	STATIC_ASSERT(16 == sizeof sin6.sin6_addr.s6_addr);
	STATIC_ASSERT(2 == sizeof sin6.sin6_port);
	STATIC_ASSERT(4 == sizeof sin6.sin6_flowinfo);
	STATIC_ASSERT(4 == sizeof sin6.sin6_scope_id);

	(void) sin6;
	(void) in6;

	return 0;
}
EOC
if $cc $ccflags $ldflags -o try try.c >/dev/null 2>&1; then
    $cat <<'EOM'
It looks like IPv6 is usable on your system, good.

I can enable support for IPv6, but this only makes sense if you have
IPv6 connectivity. IPv6 support has 16 bytes overhead for each IP
address and also some CPU overhead.

EOM
	case "$ipv6" in
	false) dflt=n;;
	*) dflt=y;;
	esac
	rp="Enable IPv6 support"
	. ./myread
	case "$ans" in
	y) ipv6=true; d_ipv6="$define";;
	*) ipv6=false; d_ipv6="$undef";;
	esac

else
	echo "Sorry, I will not be using IPv6."
	d_ipv6="$undef"
fi
$rm -f try try.c

